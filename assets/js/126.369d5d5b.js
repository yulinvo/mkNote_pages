(window.webpackJsonp=window.webpackJsonp||[]).push([[126],{391:function(t,n,s){"use strict";s.r(n);var e=s(13),a=Object(e.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h2",{attrs:{id:"生成器"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#生成器"}},[t._v("#")]),t._v(" 生成器")]),t._v(" "),n("blockquote",[n("p",[t._v("生成器是迭代器的一种特例，是特殊的迭代器，也有迭代器的'"),n("em",[t._v("_iter__'和'")]),t._v("_next__'这两个方法 ，也是可以被遍历的，区别是更节省内存，每次只能生成一个对象,拿走之后就没有了.")]),t._v(" "),n("p",[t._v("暂时这么理解：里面放了一个列表，指针指向列表中的一个元素，指针只能往前走，不能往后退")]),t._v(" "),n("p",[t._v("参考文档：https://www.bilibili.com/video/BV1BT4y1P7nn?from=search&seid=16150640023895278497&spm_id_from=333.337.0.0")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("定义：一个函数调用时返回一个迭代器，这个函数就叫做生成器(如果函数中包含yield语法，那这个函数就会变成生成器)\n\ndef cash_money(amount):\n    while amount > 0:\n        amount -= 100\n        yield 100               #执行到yield程序就中断执行了，100是执行atm.next()时返回100,接收值通过别人的send方法\n        print '又来取钱了！'\n\natm=cash_money(500)     #atm是一个生成器，\nprint type(atm)          #输出结果：<type 'generator'> ,而type(cash_money)只是一个普通函数<type 'function'>\nprint atm.next()         #实际环境中好像不太常用print next这种吧，感觉没什么用：1，需要上面yield返回  2，返回固定的值\nprint atm.next()\nprint atm.next()\nprint '出去看电影！'     #实现异步,保存函数执行过程中的中断状态,随便跳出、跳入上面的while循环\nprint atm.next()\nprint atm.next()\n")])])]),n("p",[n("strong",[t._v("#实现生成器的三种方式")])]),t._v(" "),n("p",[n("strong",[t._v("方式一：\ttuple推导式方式")])]),t._v(" "),n("div",{staticClass:"language-python extra-class"},[n("pre",{pre:!0,attrs:{class:"language-python"}},[n("code",[t._v("t "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" i "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("range")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#t.next()                        #好像没有这个方法")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" i "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" t"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("print")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),n("p",[n("strong",[t._v("方式二：\tyield")])]),t._v(" "),n("div",{staticClass:"language-python extra-class"},[n("pre",{pre:!0,attrs:{class:"language-python"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("say")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("yield")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("yield")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("yield")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" i "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" say"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("print")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\t\t\t\t"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#say()是一个生成器对象")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#t=say();\tt.next()\t\t\t\t\t#t.next()好像不支持这种写法，python2.7时好像是支持的")]),t._v("\n")])])]),n("p",[n("strong",[t._v("方式三：\t实现__iter__、next")])]),t._v(" "),n("h2",{attrs:{id:"yield"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#yield"}},[t._v("#")]),t._v(" yield")]),t._v(" "),n("blockquote",[n("p",[t._v("#执行到yield语句，就把后面的结果return了，然后将控制权交出去，调用next方法的时候就是通知又回到程序中；send()方法实际也是调用了一次next()")]),t._v(" "),n("p",[t._v("#next方法相当于send了一个空，send(None)")]),t._v(" "),n("p",[t._v("参考文档：https://blog.csdn.net/mieleizhi0522/article/details/82142856/")]),t._v(" "),n("p",[t._v("https://www.bilibili.com/video/BV1BT4y1P7nn?from=search&seid=16150640023895278497&spm_id_from=333.337.0.0")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("def say():\n    for i in range(10):\n        t = yield i\n        print(t)\nt=say()\t\t\t\t\t\t\t\t#t是一个生成器对象\nfor i in range(10,20):\n    t.send(i)\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("class Foo(object):\n    def __iter__(self):    \n        yield 1\n        yield 2\n        yield 3\n\nfor item in Foo():\n    print(item)\n")])])]),n("ul",[n("li",[n("p",[t._v("自定义循环迭代器")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("class Xarge(object):\n    def __init__(self,max_num) -> None:\n        self.max_num = max_num\n    \n    def __iter__(self):\t\t\t\t\t\t#只定义了__iter__方法，没有定义__next__方法\n        counter = 0\n        while counter < self.max_num:\n            yield counter\n            counter += 1\n\nobj = Xarge(100)\t\t\t\t#dir(obj.__iter__())中有__next__方法\nfor item in obj:\n    print(item)\n")])])])])])])}),[],!1,null,null,null);n.default=a.exports}}]);