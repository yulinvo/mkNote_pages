(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{292:function(t,a,e){"use strict";e.r(a);var s=e(13),i=Object(s.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"git视频一"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#git视频一"}},[t._v("#")]),t._v(" git视频一")]),t._v(" "),a("h3",{attrs:{id:"参考视频"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考视频"}},[t._v("#")]),t._v(" 参考视频")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://www.bilibili.com/video/BV1kK4y1S7H2?p=1",target:"_blank",rel:"noopener noreferrer"}},[t._v("7小时学会Git实战（完整版）通俗易懂_哔哩哔哩_bilibili"),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("参考文档：https://www.cnblogs.com/cxx8181602/p/11125539.html")]),t._v(" "),a("h3",{attrs:{id:"git下载-安装"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#git下载-安装"}},[t._v("#")]),t._v(" git下载/安装")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("#直接在联想软件管理中心安装的Git\n")])])]),a("h3",{attrs:{id:"init"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#init"}},[t._v("#")]),t._v(" init")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("#mkdir test123 && git init   或者 git init test123 \t\n.git的目录结构如下：\n    hooks 目录包含客户端或服务端的钩子脚本；\n    info 包含一个全局性排除文件\n    logs 保存日志信息\n    objects 目录存储所有数据内容；                ！！！！\n    refs 目录存储指向数据的提交对象的指针（分支）\n    config 文件包含项目特有的配置选项\n    description 用来显示对仓库的描述信息\n    HEAD 文件指示目前被检出的分支\n    index 文件保存暂存区信息\n")])])]),a("h3",{attrs:{id:"head"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#head"}},[t._v("#")]),t._v(" HEAD")]),t._v(" "),a("blockquote",[a("p",[t._v("HEAD指向的是本地版本库，不是本地工作区也不是暂存区！！！！！！！！！")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("HEAD是一个指针，指向最新的位置   （.git/HEAD）\n\n$ cat HEAD\n\tref: refs/heads/master\t\t\t\t#查看当前的指针位置\n$ cat refs/heads/master\n\t7f271baee54799931c2672d8764fcd4382bee33d\n\t\n分支的本质：\n\trefs/heads/master|test 中保存的是最近一次提交的hash值(应该是commit的hash值)\n\tHEAD中保存的是当前的指针，指向当前所在的分支(refs/heads/master|test)\n")])])]),a("h3",{attrs:{id:"object-git目录下"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#object-git目录下"}},[t._v("#")]),t._v(" object（.git目录下）")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("$ echo 'test content' | git hash-object -w --stdin  #输出一串hash值（hash值的前面两位作为了目录名称、后面的作为了文件名）\n$git hash-object -w ./abc.text\t\t\t\t#object中只是 hash--单个文件 的对应关系，并不会存储版本信息！！！！！！\n\n$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4            #根据hash值方向输出内容\n$ git cat-file -t d670460b4b4aece5915caf5c68d12f560a9fe3e4            #hash值存储的类型\n#git cat-file -t  ${refs/heads/master}\t#查看类型；将变量的值改为master文件中的hash值即可\n#git cat-file -p  ${refs/heads/master}\t#查看内容\ngit对象：\tkey:value 组成的键值对（key是val对应的hash，即上面的d67xx:'test content' ）\n\t\t键值对在git内部是一个blob类型\n\n\n树对象：     #git update-index 【往暂存区添加一条记录存到.git/index】/ git write-tree【生成树对象存到.git/objects】\n提交对象：   #git commit-tree treehash【生成树对象存到.git/objects】\n\ngit ls-files [-s]\t#查看暂存区中的文件，-s显示详细信息\n")])])]),a("p",[t._v("#09 探秘")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("refs中包含了几项：heads/tags/remotes\n\t所以删除远程tag可以： git push origin :refs/tags/3.0 但是修改远程分支名称却不能用这种方法(refs/for/dev不存在)\n\t\nrefs/heads/[master|dev] 存放的是commitID\t\t#07:55\n\tgit cat-file -t ${refs/heads/master}\t#是一个commit类型\n\tgit cat-file -t ${refs/tags/v1.0}\t\t#是一个tag类型,refs/tags/v1.0中存放的是一个commitID提交信息\n\tgit cat-file -p ${refs/tags/v1.0}\t#查看存放的内容，是一个object\n\t\nobjects：\t\t\t\t#11.00\n\n\tcommit\n\ttree\t\t#这个可以理解为文件夹\n\tblob\n")])])]),a("p",[t._v("#P10 commit、tree、blob三个对象之间的关系")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("一个commit对应一个tree\nblob跟文件名没有关系\n")])])]),a("p",[t._v("#P11 数一数tree的个数")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('创建单文件夹，文件夹中创建单文件，add然后commit查看objects中数据的变化：\n\t1，创建文件夹doc，因为文件夹中没有文件，git不会去探测\n\t2，文件夹中创建readme文件，文件里面输入内容"hello world"\n\t3，文件只要加入到暂存区 git就会创建blob\n\t4，commit之后objects中会有4个文件：\n\t\t- blob文件，内容为"hello world"\n\t\t- tree文件，内容为doc\t\t\tkey：doc  value：hash值\n\t\t- tree文件，内容为blob\t\tkey：readme\tvalue：hash值\n\t\t- commit文件，\n')])])]),a("h3",{attrs:{id:"基础命令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基础命令"}},[t._v("#")]),t._v(" 基础命令")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git add \t\t#提交到暂存区\t\t #P07 05.00\n\t#add后，之后每次修改都需要重新add，如果不想保存更改信息，需要git restore <file>\n\t#文件add之前是红色的,add之后是绿色的，表示已经纳入到git的环境中了（这个也是比较合理的，被管理的是绿色，没有被管理的是红色）\n\ngit commit\t\t\t#提交到版本库\t\t#P07 \t05.05\n\ngit log\t\t\t\t#在合并分支之前，master上是看不到dev分支上的commit记录的\n\ngit reset --hard commitID\t\t\t\t\t#回滚\t\t#P07 13.25\n\t#回滚后git log只能查看到当前，截至到当前之后的就看不到了\ngit reflog\t\t#日志信息，不受回滚的影响\t\t\t#P07 20.00\n\n")])])]),a("h4",{attrs:{id:"删除文件并提交"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#删除文件并提交"}},[t._v("#")]),t._v(" 删除文件并提交")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1,rm -f abc.txt\n2,git add ./\n2,git commit -m 'xx'\n\n#上面的步骤合并为两步：git rm abc.txt aaa.txt; git commit -m 'xx'       #git rm相当于是合并了步骤1、步骤2\n\t#abc.txt/aaa.txt要曾经add过\n")])])]),a("h4",{attrs:{id:"rename文件并提交"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rename文件并提交"}},[t._v("#")]),t._v(" rename文件并提交")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1,mv  abc.txt   aaa.txt\n2,git add ./\n2,git commit -m 'xx'\n\t\n#上面的步骤合并为两步：git mv abc.txt 123; git commit -m 'xx'               #git mv相当于是合并了步骤1、步骤2\n\t#abc.txt要曾经add过\n")])])]),a("h3",{attrs:{id:"commit"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#commit"}},[t._v("#")]),t._v(" commit")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('git commit -s \t\t\t\t\t\t\t\t\t\t添加用户签名信息\ngit commit --amend \t\t\t\t\t\t\t修改上次提交\n\ngit commit\t\t\t\t\t#不加-m，再弹出的vim中输入注释信息也是一样的（需要先add文件）\ngit commit -a \t\t#跳过使用暂存区域，前提是必须是已经跟踪过的文件(曾经add过的文件)，直接在弹出的窗口编辑commit信息\n\t#-am提交注释时，"a"一定要写在"m"的前面\n\ngit rebase -i commitID\t\t#删除提交记录，交互框中选择"d"\n')])])]),a("h4",{attrs:{id:"commit、branch、tag之间的关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#commit、branch、tag之间的关系"}},[t._v("#")]),t._v(" commit、branch、tag之间的关系")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1，master分支创建master01文件，add && commit后打上tag：master01_tag\n2，devr分支创建dev01文件，add && commit后打上tag: dev01_tag\n3，master分支创建master02文件，add && commit后打上tag：master02_tag\n\n测试：\n\t- 此时在master分支上： git reset --hard dev01_tag，发现：master分支上只有master01和dev01两个文件，并不是master01和master02两个文件（即：此时将master分支文件还原到了dev01_tag的状态），然后git ll查看(HEAD -> master)指向了dev01_tag的commit提交【即在同一行:  0ab0aaf (HEAD -> master, tag: dev01_tag) add dev01 file】\n\n结论：\n\t#commitID保存就是当前文件夹下的所有内容，和分支没有关系，就是提交的时候文件夹下的所有内容！！！！！！！！！！！\n\t#接上，即此commitID就是一个文件快照（比如此时有5个文件，那这个commitID就是对应了这5个文件）！！！！！！！！！\n")])])]),a("h4",{attrs:{id:"git-log-oneline-all-graph历史"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#git-log-oneline-all-graph历史"}},[t._v("#")]),t._v(" git log --oneline --all --graph历史")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("当有提交没有merge时git ll查看")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("#没有merge时查看，6c48e4b是没有向上合并的线路的，相当于是基于7f271ba创建了新分支，新分支上做了两次提交但是没有合并\n    * 9bb2f81 comm 4.0\n    | * 6c48e4b (tag: 5.0, origin/zjh, origin/dev, origin/ddz, ddz) comm 5.0  #注意此处没有向上合并的线路\n    | * ef31ce1 (tag: 4.4, tag: 4.0) comm 4.0\n    |/\n    * 7f271ba (origin/master, origin/HEAD, master) dev 3.0\t\t#图示在此处创建了两个分支！！！！！\n\n#此时git cat-file -p 9bb2f81发现只有一个parent  ！！！！\n")])])])]),t._v(" "),a("li",[a("p",[t._v("当有提交merge之后git ll查看")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("merge合并后查看，d977e19是有向上合并的线路，相当于基于91f9389创建了新分支，新分支上做了两次提交，并提交合并了\n    *   93df1f9 v11\n    |\\\n    | * d977e19 03commit\n    * | 4b7b32a v11\n    |/\n    * 91f9389 my site 2.0\t\t\t\t\t#图示在此处创建了两个分支！！！！！！！！\n        \n#此时git cat-file -p 93df1f9发现有2个parent\t！！！！\n")])])])])]),t._v(" "),a("h3",{attrs:{id:"工作区、暂存区、本地版本库"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#工作区、暂存区、本地版本库"}},[t._v("#")]),t._v(" 工作区、暂存区、本地版本库")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("#P08 03.00开始\t\t\t\t\t\t\t#重复观看\n\n#工作区、暂存区、版本库之间的关系！！！！！！！！！\t\t#P08 02.20\ngit reset --soft 版本号\t\t#回滚到暂存区！！！\t\t#commit后的内容reset返回的时候，都有使用【版本号】来回滚\ngit reset --hard 版本号\t\t#从版本库回到工作区\ngit reset --mix 版本号\t\t\t#从版本库回到红色的工作区（文件没有被add时的状态、新文件或有变动文件时的状态）\n\t#不带参数的话(soft/hard/mix都不带)默认就是mixed\n\t#https://www.bilibili.com/video/BV1BE411g7SV/?spm_id_from=trigger_reload  \t#09:00\n\ngit reset HEAD\t<files>\t\t\t#将暂存区回滚到未追踪时的工作区(文件状态由：绿色变为红色)\n#测试：git reset a4a11e5会将index.html回退到暂存区，此时在git reset --hard commitID会：1回退到对应的版本，2清空暂存区\n\ngit checkout  -- <files>\t  #这个和git restor类似(应该是新版本中使用git restor，老版本中使用git checkout？？？)\n\n")])])]),a("h3",{attrs:{id:"reset"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reset"}},[t._v("#")]),t._v(" reset")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("#git reset --hard\t\t\t#如果commitID缺省应该是HEAD\n")])])]),a("h3",{attrs:{id:"设置alias别名"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#设置alias别名"}},[t._v("#")]),t._v(" 设置alias别名")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git config --local alias.ll 'log  --graph --pretty=format:\"%h %s\" --oneline'\ngit config --local alias.ll 'log  --graph --pretty=format:\"%h %s\" --oneline --decorate --all'\ngit config --local alias.mc 'commit -m'\t\t#'commit -m '后面有空格的时候使用别名会报错\n\n如果后面只有一个单词的就可以不加引号，比如git config --global alias.st  stuts\n")])])]),a("ul",[a("li",[a("p",[t._v("删除alias别名")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("$ git config --unset alias.ll\t\t\t\t#删除alias别名，默认操作的是--local下的\n")])])])])]),t._v(" "),a("h3",{attrs:{id:"branch"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#branch"}},[t._v("#")]),t._v(" branch")]),t._v(" "),a("blockquote",[a("p",[a("strong",[t._v("git branch -h\t\t\t\t#查看帮助命令\t！！！！！！！！！！！")])])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("增")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git branch 新分支名 [基准分支/标签/commit]\t\t\t\t #新建一个本地分支\n")])])])]),t._v(" "),a("li",[a("p",[t._v("删")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git branch -d bug\t\t\t\t\t\t\t\t#删除bug分支（当分支有内容未合并时，使用-D强制删除）\n\n删除远程分支\n\tgit push origin --delete serverfix\t\t#删除远程分支（远程serverfix分支下有无文件都可以删除）\n\t\n\tgit remote prune origin --dry-run\t\t\n\t\t#列出仍在远程跟踪但是远程已被删除的无用分支（远程分支以被删除，远程跟踪分支还存在的）\n\tgit remote prune origin\t\t\t\t\t#接上， 清除上面命令列出来的远程跟踪\n")])])])]),t._v(" "),a("li",[a("p",[t._v("改")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("# git branch -m v1.0  v2.0\t\t\t\t\t#修改本地分支名称\n# git branch -M main\t\t\t\t\t\t#将master分支改名为main分支（在master分支上执行）\n\n如何修改远程分支名呢？ \n\t还是说将本地分支名称修改push后，远程的名称也自动改了？（这种方式测试过不行，远端会同时保留新、旧两个分支）\n\tgit push  origin  dev:refs/for/dev123\t#不生效，什么都不会改变，远端既没有新建dev分支(如果没有)更没有重命名\n\tgit push  origin  dev:dev123\t\t\t#不是将dev名称改为dev123，而是在远端新建一个分支dev123\n")])])])]),t._v(" "),a("li",[a("p",[t._v("查")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("每一个名称的分支都有两个，一个是本地，一个是远程，因为代码可能会推送到多个远程仓库，所以remotes/不同的仓库名/远程分支名：\n    master\n    dev\n    remotes/origin/master\n    remotes/origin/dev\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git branch -av\n\ngit branch  [-r/-a]\t\t\t\t\t\t\t\t   #查看本地分支，-r远程分支，-a所有分支\ngit branch -v\t\t\t\t\t\t\t\t\t\t#可以查看每一个分支的最后一次提交\n\ngit branch –-merged\t\t\t\t#查看哪些分支已经合并到当前分支;在这个列表中分支名字前没有 * 号的分支通常可以使用;\ngit branch --no-merged\t\t\t#查看所有包含未合并工作的分支;\n")])])])])]),t._v(" "),a("h4",{attrs:{id:"master分支"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#master分支"}},[t._v("#")]),t._v(" master分支")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("master分支也可以被删除（在其他分支上执行）\t\t#master也只是指向了一次commit提交对象而已\n\t#删除master分支：git branch -d master\n\t#创建master分支：git checkout -b master 82843a4\n")])])]),a("h4",{attrs:{id:"主分支如何确定"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#主分支如何确定"}},[t._v("#")]),t._v(" 主分支如何确定")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("首先开宗明义：主分支跟master/dev是没有关系的，只跟commit提交历史有关系，所谓的branch分支都是在此提交历史上做的分叉\n\n1. git init 并add && commit后会有一个commitID，此时这个提交就是根（通常是master分支，原因见下面一行）\n\t#因为commit之后才会有master分支，所以没法在提交之前删除master分支，所以第一次提交通常是在master分支下\n2，如果在根的基础上创建dev分支，git ll查看就分叉了，是基于第一次提交去做的分叉\n\n")])])]),a("p",[a("strong",[t._v("问题：")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("#如何查看分支是基于哪个分支创建的，如果有10个分支，怎么查看他们之间的依赖关系呢？？？  #git log可以看到类似下面的解构：\n\tcommit02 (HEAD -> dev)\n\tcommit01\n    ${baseCommit00} (master)\n    #说明当前的dev分支是在master分支的${baseCommit00}提交基础上，做了两次提交commit01和commit02\n")])])]),a("p",[a("strong",[t._v("git ll上能看到分叉的条件")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("#不涉及master分支，是在dev分支上操作，master上原理相同\n\n1，dev上切出去一个分支test，在test上创建文件并提交\n2，在dev分支上创建文件并提交，使得当前dev的状态和创建test分支时状态不同\n3，在dev分支上执行：git merge test，然后执行git ll 查看就有分叉了\n")])])]),a("h3",{attrs:{id:"分离头指针"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分离头指针"}},[t._v("#")]),t._v(" 分离头指针")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("分离头指针：即工作在没有分支的情况下（HEAD没有指向具体的分支）\n\ngit checkout CommitID\n\n分离头指针有利的使用场景：如果只是想做一些尝试性的变更，如果效果不好的话就随手丢弃了\n\t1，git checkout CommitID修改文件后add && commit提交，是能够提交成功的\n\t2，查看git log查看HEAD并没有绑定分支（commitID -- HEAD）！！！！！！！！！\n\t3，git checkout master 此时会有提示信息，提示如果想用的话新建一个分支\n\t4，使用gitk --all查看并没有步骤一中对应的commit信息\n\t5，按照步骤三中的提示创建一个新的分支，此时操作就保留了下来了\n\t\n\t问题：如何确实不需要保留修改，git会如何处理？ 要怎么验证被丢弃掉了呢\n\t\t#步骤1或3 提示消息的commitID不会被记录，提示消息消失后，commitID就找不到了\n\n#注意分离头指针只是没有对应的分支，HEAD是有值的(git ll查看能看到)，所以依然可以执行git reset HEAD之类的回退动作\n")])])]),a("h3",{attrs:{id:"进一步理解head和branch"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进一步理解head和branch"}},[t._v("#")]),t._v(" 进一步理解HEAD和branch")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("比较相邻的两个commit之间有什么差异：\t\t\t#04.30\n\tgit diff commitID1 commitID2\n\tgit diff HEAD HEAD^\n\tgit diff HEAD HEAD~1\n\tgit diff HEAD HEAD^1\n\tgit diff HEAD HEAD^^\t\t\t#这个应该是指全局的吧(git log --all)\n\tgit diff HEAD HEAD^1^1\n\n测试：git ll && git checkout HEAD^ \t查看commit提交记录在git ll历史的移动！！！！！\n\t#一：只在主线上（git ll左侧的主线，而不是master分支的主线）回退。  主线：纯粹是以commit记录先后为准，跟分支没关系！！！！\n\t#二：接上，主线上dev分支可以在master前面\n\t#三：有分叉的时候（即有两个parent时），git checkout HEAD^时好像只会回退到左侧主线上的版本，不会回退到右侧分叉的版本!?\n")])])]),a("h3",{attrs:{id:"gitk"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#gitk"}},[t._v("#")]),t._v(" gitk")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('分支删除前先看下分支的树形结构：\t\t\t#02.00\n\tgitk --all\t\t#绿色的是分支（可以看到多个分支对应同一个commit），<开头的是tag\n\t\t#commit <-- tag/branch\t\t#是branch对应commit！！！！！！！！！！！！！！！！！\n\n注意gitk 查看完整的分支树：view的定制--new views -- 选中"All refs"\n')])])]),a("h3",{attrs:{id:"checkout"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#checkout"}},[t._v("#")]),t._v(" checkout")]),t._v(" "),a("blockquote",[a("p",[t._v("git checkout dev 切换分支实际上等效与执行 git reset --hard dev（或者dev对应的commit）")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git checkout 分支名：\t\t\t\t\t\t\t\t\t#检出到指定分支\ngit checkout -b 新分支名 [已有分支名称/标签/commit]：\t\t\t#新建并检出分支\n\n#git checkout -b feature origin/feature\n#git checkout -t origin/feature          #作用同上，使用-t参数，它默认会在本地建立一个和远程分支名字一样的分支\n\n最佳实践：每次切换分支前，当前分支一定要是干净的（git status中没有暂存的内容，没有红色的也没有绿色的内容）！！！！！！！\n一个坑：\n\t1,在分支中新建一个c.txt，未跟踪(没有add)此时切到master分支，发现master分支也能看到c.txt了(污染了主分支，此时如果切回到master分支，删除新建的分支，文件就被保留到master分支上了，master分支就被彻底污染了)\n\t\t#add了没有commit也是一样\n\t\t#切换会分支将c.txt重新commit之后，master也正常了\n\t2，上面的情况是初始化的时候，不是初始化的情况：当c.txt文件被commit过后，再次修改c.txt时，没有commit之前是强制不允许切换到master分支的\n")])])]),a("h3",{attrs:{id:"log"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#log"}},[t._v("#")]),t._v(" log")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("--online :\t\t\t单行显示；\t -数字：显示最近几条记录\n-- 文件名：\t\t\t查看指定文件的修改记录\n-p：\t\t\t\t\t显示代码变动；--stat：显示文件变动概要（文件名，修改行数等）\n--reverse\t\t\t#逆向显示日志信息（最先提交的在最前面）\n\ngit log --all\t\t\t#查看所有分支的commit历史\ngit log -n4 \t\t\t#查看最近的4次提交记录\ngit log -4 \t\t\t\t#好像也可以\n\ngit log --oneline --all --graph\t\t#这个也不能查看最新分支之后的提交，也是需要git reflog来查看！！！！！\n")])])]),a("h3",{attrs:{id:"gitk图形界面查看log版本历史"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#gitk图形界面查看log版本历史"}},[t._v("#")]),t._v(" gitk图形界面查看log版本历史")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('gitk\t\t\t#git bash界面直接输入gitk会弹出图形界面\n\t#弹出的界面上点击tag不会触发下方的sha1 ID变化，点击branch或commit注释信息会触发\n\nCommitter提交者和author不同的情况：\t\t\t#02.30\n\t#版本穿梭的时候会不一致\n\n查看完整的分支树：view的定制--new views -- 选中"All refs"，命名为view01，可以在view中直接选中view01（没有关闭界面的情况下）\n')])])]),a("h3",{attrs:{id:"diff"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#diff"}},[t._v("#")]),t._v(" Diff")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("#diff比较的好像是当前的状态和版本库中的文件区别\n\n--文件名：\t\t查看指定文件的修改记录\n\n#git diff\n#git diff  HEAD -- hello.py\t\t\t#查看工作区和版本库里面最新版本的区别\n")])])]),a("h3",{attrs:{id:"merge"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#merge"}},[t._v("#")]),t._v(" Merge")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git merge bug\t\t\t#P11 08.40\t\t\t#merge提交时会弹出一个新的窗口，用来输入合并的commit信息\n\ngit merge dev\t\t\t#分支之间冲突的时候如何处理\t\t\t #P11 12.45\n\t#vim ${冲突文件}\t\t手动逐行修改\n\t#解决冲突后，git add && git commit\n\n===============================================\n文件名称冲突： \n\t现象：git merge origin/js报错（在master分支上执行）：CONFLICT (rename/delete): 网页左侧列表--未完成/temp.css renamed to 01二级菜单--未完成/temp.css in origin/js, but deleted in HEAD.\n\t处理方法：\n\t总结：注意此处的分支名为【(master|MERGING)】，是一种中间态的，实际上js分支上的内容已经全部合并过来了，此状态包含两个分支上的所有的文件，所以在此处去解决冲突（改名、vim修改文件冲突内容等）！！！！！！！！！！！！！！！！！！！\n")])])]),a("h3",{attrs:{id:"tag"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tag"}},[t._v("#")]),t._v(" tag")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("#P23  11.10\n\ngit push origin --tags\t\t\t\t\t\t#这个为啥不需要指定分支名称呢？？？\ngit push origin v1.0 \t\t\t\t\t\t#推送某个tag\n")])])]),a("ul",[a("li",[a("p",[t._v("增")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git tag v1.4  [commitHash]  [-m 'tag message xxx']\t\t\t\t#如果不指定commitHash，默认当前HEAD\ngit tag -a v1.4\t\t\t\t\t\t\t\t#-a可以添加一些注释信息\ngit tag -a v1 -m \"第一版\"  && git log\t\t#使用当前的HEAD的commitID,使用git log可以看到commit上多了一个tag信息\n")])])])]),t._v(" "),a("li",[a("p",[t._v("删")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git tag -d v1.4\ngit push origin  :refs/tags/v1.4\t#删除远程代码仓库里的tag（实际上是本地的[空标签]推送到远端的v1.4，相当于删除）\n")])])])]),t._v(" "),a("li",[a("p",[t._v("改")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("如何修改远程仓库中tag的名称？\n")])])])]),t._v(" "),a("li",[a("p",[t._v("查")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git tag\t\t\t\t\t\t\t\t\t\t#列出所有的tag\ngit tag -l 'v1.8.5*’\t\t\t\t\t\t#列出所有以v1.8.5开头的版本\n\n查看特定标签（这个用的好像不多）\n\tgit show tagname\t\t#git show 可以显示任意类型的对象（git 对象 树对象 提交对象 tag 对象）\n\n查看当前状态在哪个tag上：git log --oneline (git tag好像没有类似的查看命令)\n")])])])]),t._v(" "),a("li",[a("p",[t._v("检出标签")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git checkout v1.0     #只执行这个会有头部分离的警告(因为HEAD没有指向分支)，还要使用下面的命令检出分支\n\tgit checkout -b version2\t#为啥要新建，添加tag后就只能检出新分支不能切换到对应的分支么？？？\n")])])])]),t._v(" "),a("li",[a("p",[t._v("遇见的一个问题")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1.0/2.0/3.0三个tag标签，远程和本地都是3.0的状态，此时发现有问题需要【将master分支】退回到2.0版本，此时git reset --hard 2.0后发现git push无法推送，感觉tag和dev分支好像不太一样，tag只针对master么？？？\n")])])])])]),t._v(" "),a("h3",{attrs:{id:"clone"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#clone"}},[t._v("#")]),t._v(" clone")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git clone git@xxx.git abc12111\t\t\t#abc12111是clone后的新名称\n\ngit clone https:xx / git@github.xx\t\t#注意：同样是public的仓库，https克隆不需要认证，ssh地址需要认证，为啥？？？\n")])])]),a("ul",[a("li",[t._v("git clone下来的代码只显示master一个分支，其实是已经全部拉下来了，不需要额外处理\t\t#P14   15.10")])]),t._v(" "),a("h3",{attrs:{id:"remote"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#remote"}},[t._v("#")]),t._v(" remote")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git remote rm origin //删除关联对应的远程仓库地址\t\t#git remote remove origin\ngit remote get-url origin //查看远程仓库地址\ngit remote set-url origin https://github.com/developers-youcong/Metronic_Template.git\t\t//修改remote地址\n\n")])])]),a("h3",{attrs:{id:"push"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#push"}},[t._v("#")]),t._v(" push")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git push origin 本地分支名:refs/for/远程分支名\n\t#git push -f origin master:gh-pages\t\t#将本地的master分支推送到远端，并将远端上的该分支命名为gh-pages\n\ngit push origin master\t\t\t#将本地的master分支推送到远程仓库\ngit push origin dev\t\t\t\t#将本地的dev分支推送到远程仓库\n\n\n-u:\n\tgit push -u origin master\t \t#-u可写可不写\t\t#P14\t06.50\n\tgit\tpush -u origin dev\t\t\t#默认是不会推送dev分支的，要另外推送下\t\t#P14 11.30\n\t\n")])])]),a("h3",{attrs:{id:"pull"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pull"}},[t._v("#")]),t._v(" pull")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git checkout dev &&\tgit pull origin dev\t\t#一定要切换到dev分支之后在执行pull么？？？  #P15  07.00左右\n\ngit pull origin dev 等同于下面两条命令：\t\t\t#P16 15.40\t很重要，重复观看！！！！！\n\tgit fetch origin dev\t\t#将远程仓库代码拉到本地的版本库，而不是直接拉到工作区\n\t\t#git fetch origin\t\t#看之前的笔记应该是可以不写分支名的\n\tgit merge origin/dev \t\t#将版本库的代码更新到工作区\n")])])]),a("p",[a("strong",[t._v("pull的时候解决冲突")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("#vim ${冲突文件}\t\t#手动逐行修改，不过课件中修改后好像没有手动add && commit的过程\t\t#P16 11.50\n\t#解决冲突后应该也是要add && commit && push的\n")])])]),a("h3",{attrs:{id:"rebase"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rebase"}},[t._v("#")]),t._v(" Rebase")]),t._v(" "),a("blockquote",[a("p",[t._v("作用：将代码的提交记录变得简洁")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("第一种：将多个commit整合成一个提交记录")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("#git rebase -i commitID(旧的提交记录)\t\t#将从commitID到当前HEAD的合并成一个提交记录\t\t\t#P17 07.00\n\t#-i是交互式的rebase\n\t\n#git rebase -i HEAD~3\t\t\t#从当前开始，找最近的3条记录进行合并\n\t#之后还要vim进行修改合并的顺序，然后还要进行vim修改提交的commitID信息\n\t\n#注意：已经提交到远程仓库的代码，尽量不要进行合并（那这样的话，好像就用处不大了吧！！！）\t\t#P17 10.55\n")])])])]),t._v(" "),a("li",[a("p",[t._v("git merge 后，git log查看dev分支上在master分支上的位置好像是根据时间先后顺序排列的")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("#P18 07:20\t此处展示的树结构\n\n#自己的总结：好像不管是merge还是rebase，底层的以【时间先后顺序排列】的规则是不变的，这应该是git的一个基本的规则！！！！\n\ndev是rebase && master上merge，此时在master上查看log也没有分叉了，用merge也可以没有分叉！！！！！！ \t #P18 09:20\n\t#这个不是的，依然会产生分叉，只是这个情况比较特殊，master上内容没有更改是和dev是保持一致的，如果master有更改的话，依然是会产生分叉的！！！\n")])])])]),t._v(" "),a("li",[a("p",[t._v("分支rebase合并")]),t._v(" "),a("blockquote",[a("p",[t._v("git rebase的应用场景为：master分支上有更新，dev分支同步master分支的更新时，使用git rebase master（dev在master分支上的时间点已rebase的时间点为准，而不是以创建dev分支的时间点为准！！！！！！）")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('git log --graph\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#P18 07.50\ngit log --graph\t --pretty=format:"%h %s"\t\t\t\t\t\t\t\t\t#P18 08.40\n\t#--pretty=oneline和--oneline的区别是：同样都是一行显示，--oneline输出时hash值变短了\n\n\ngit checkout dev && git add && git commit  && git rebase master \t\t\t#P18 11.00\ngit rebase master的时候（master上代码有更新时），dev上的分支上原有的commitID也变化了(根据时间重新生成了commitID替换掉原来的commitID)\n\ngit pull 会在git log中产生分叉(git log --oneline --graph)\t\t\t\t\t#P19 03.00左右\ngit fetch  && git rebase origin/dev\t\t#这样就不会产生分叉了     \t\t\t #P19 04.00左右\n')])])]),a("p",[t._v("参考文档：")]),t._v(" "),a("p",[t._v("#https://www.bilibili.com/video/BV1Qb411N7ay?from=search&seid=16412934312561339544&spm_id_from=333.337.0.0")]),t._v(" "),a("p",[t._v("#https://www.jianshu.com/p/4079284dd970")]),t._v(" "),a("p",[t._v("#https://www.bilibili.com/video/BV1dp4y1v748?from=search&seid=16412934312561339544&spm_id_from=333.337.0.0")]),t._v(" "),a("p",[a("strong",[t._v("注意")])]),t._v(" "),a("ol",[a("li",[t._v("在公共分支（如master分支）上尽量不要使用rebase（因为git rebase会重写提交历史），尽量在自己的分支上使用rebase，公共分支上使用merge")])])]),t._v(" "),a("li",[a("p",[t._v("Rebase解决冲突\t\t\t\t\t\t\t#P19 \t06.40")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1，手动逐个解决冲突\n2，git add .\n3, git commit or git rebase --continue\n\t#冲突演示：\t\t#master和dev同时修改同一个文件\t\t\t\t#P19 07.45\n\n#git checkout -m -- filename找回冲突现场\n")])])])])]),t._v(" "),a("h3",{attrs:{id:"stash存储"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#stash存储"}},[t._v("#")]),t._v(" stash存储")]),t._v(" "),a("blockquote",[a("p",[t._v("使用场景：需要切换分支时，当前分支上的内容没有写完不想commit提交，针对这种情况，可以使用存储")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git stash 命令会将未完成的修改保存到一个栈上，而你可以在任何时候重新应用这些改动(git stash apply) #需要先add可以不commit\ngit stash\t#将当前未完成的工作存储下，此时在git status查看已经没有这些未提交的东西了(实际上相当于做了commit提交只是没有记录，使用git log --online查看没有记录)\n\ngit stash list: \t\t\t\t#查看存储\ngit stash apply stash@{2}\t\t#如果不指定一个储藏，Git 认为指定的是最近的储藏\n\t#git stash apply \t直接使用栈顶的元素\ngit stash drop stash@{2} \t\t\t\t\t加上将要移除的储藏的名字来移除它\n\t#如果什么都不加会不会删除栈顶的元素\ngit stash pop\t\t#使用储藏然后立即从栈上扔掉它，这个用的比较多，相当于是git stash apply 和 drop两个功能合并了\n")])])]),a("h3",{attrs:{id:"beyond-compare快速解决冲突"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#beyond-compare快速解决冲突"}},[t._v("#")]),t._v(" beyond compare快速解决冲突")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git中配置beyond compare \t\t\t\t\t\t\t\t\t\t\t\t\t#P20 05.00\n\tgit config --local merge.tool bc3\t\t\t\t#local是只在当前项目中生效\t\t\t   #P20 07.50\n\tgit config --local mergetool.path '/usr/local/bin/bcomp'\n    git config --local mergetool.keepBackup false\t\t\t#解决冲突后不用保留源文件了\ngit mergetool \t(在merge之后操作的，merge时提示有冲突然后启动此命令)\t\t\t\t\t\t\t\t\t#P20 07.10\n")])])]),a("h3",{attrs:{id:"多人协同开发"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多人协同开发"}},[t._v("#")]),t._v(" 多人协同开发")]),t._v(" "),a("ul",[a("li",[t._v("gitflow工作流")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('多人同时开发一个"赌博"功能的时候，创建两个分支，每个分支都是从dev分支上拆分出来的，而不是直接从master分支上拆的 \t#P22 07.00~08.00要重复观看下\n\ngitflow工作流\n')])])]),a("h4",{attrs:{id:"邀请成员"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#邀请成员"}},[t._v("#")]),t._v(" 邀请成员")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("方式一：创建项目并邀请成员\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#P23\t04.30")])]),t._v(" "),a("li",[a("p",[t._v("方式二：先创建组织（将成员加入到该组织中），在组织中创建项目\t\t\t\t\t\t       #P23\t06.20")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("#一个组织中可以包含很多个仓库，同样的一个组织中也可以包含多个成员\n\n#注意看组织中创建好的项目路径(http://github.com/oldboy-org/xx.git)，说明这个组织名称和用户名称是同级别的\t#P23 08.45\n")])])]),a("ul",[a("li",[a("p",[t._v("将成员拉入到组织中\t\t\t\t\t\t\t\t\t#P24\t03.5")])]),t._v(" "),a("li",[a("p",[t._v("成员权限")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("默认情况下，成员权限是只读，不能提交\t\t\t\t\t\t\t#P25 00.20\n成员权限：对组织赋权/对组织中的项目进行赋权\t\t\t\t\t  #P25 01.00左右\n")])])])])])])]),t._v(" "),a("h4",{attrs:{id:"pull-request"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pull-request"}},[t._v("#")]),t._v(" pull request")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("添加/配置 合并规则来进行代码的review（网页端配置）\t\t\t\t\t\t\t\t#P26\t02.10")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("即：(git bash界面)代码merge的时候，git会自动将代码挂起，等待review之后才能继续merge\n#接上，好像不是，需要在web页面端提交\t\t\t\t\t#P26  05.00\n")])])])]),t._v(" "),a("li",[a("p",[t._v("网页端合并完成后，本地的git仓库的后续操作：\t\t\t\t                                    #P26  10.10")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("为啥git pull origin dev的时候，还需要看下当前是哪个分支？？？\t\t\t#P26 10.25\n")])])])]),t._v(" "),a("li",[a("p",[t._v("测试上线")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("review代码时可以指定review人员\t\t\t\t\t\t\t\t\t #P27  04.10\n代码的review或是merge的时候，产生冲突如何处理（手动解决）\t\t\t\t#P27  09.50\n")])])])])]),t._v(" "),a("h3",{attrs:{id:"给开源软件贡献代码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#给开源软件贡献代码"}},[t._v("#")]),t._v(" 给开源软件贡献代码")]),t._v(" "),a("blockquote",[a("p",[t._v("#P28")])]),t._v(" "),a("ol",[a("li",[a("p",[t._v("fork源代码")])]),t._v(" "),a("li",[a("p",[t._v("创建pull request")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('创建pull request的两个位置：\n\t1，在分支名称的右侧可以新建\n\t2，在"代码/Issues/Pull Requests"这里也可以新建\n')])])])])]),t._v(" "),a("h3",{attrs:{id:"git配置文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#git配置文件"}},[t._v("#")]),t._v(" git配置文件")]),t._v(" "),a("h4",{attrs:{id:"local-global-system配置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#local-global-system配置"}},[t._v("#")]),t._v(" local/global/system配置")]),t._v(" "),a("blockquote",[a("p",[t._v("#P29")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("--local\t\t\t\t\t#缺省默认是local  ！！！\t\t\t\t\t\t\t    #文件存放位置：.git/config")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git config --list --local\t\t\n\t#查看config的配置信息(如果不加--local这些，默认会将--local/global/system下的配置都会列出来)\n\t#git config  --local user.name\n")])])])]),t._v(" "),a("li",[a("p",[t._v("--global\t\t\t\t \t\t\t\t\t            #文件存放位置：~/.gitconfig")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git config --list --global\t\t#查看config的配置信息\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("设置账号信息:\t\t\n\t# git config --global user.email \"you@example.com\"\n\t# git config --global user.name \"Your Name\"\n\t\t#如果gloabl和local都设置了user.name、user.email，以local为准； 测试方法：git commit之后查看git log提交信息中的author中的name和email\n\t\n\t删除账号信息：git config --global --unset user.name \t\t\t#如果不行，就把用户名也加上\n\n输入用户名密码:\t\t#就是登录gitee网页的账号密码！！！\n\t# git push\n        Username for 'https://gitee.com': yulinvo\n        Password for 'https://yulinvo@gitee.com': xx\n")])])]),a("p",[t._v("#push的时候，--global中配置的user、email可以推送到github中，clone下载之后也会有；但是项目目录下配置的用户信息不会push上去，what （这是之前的笔记）？")])]),t._v(" "),a("li",[a("p",[t._v("--system\t\t\t\t\t\t\t                   #文件存放位置：/etc/gitconfig\t\t(注意：需要有root权限；gitconfig没有点，不是隐藏文件)")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git config --list --system\t#查看config的配置信息\n")])])])])]),t._v(" "),a("p",[t._v("优先级（从高到低）：本地 > 全局(global) > 系统")]),t._v(" "),a("h4",{attrs:{id:"pageup-pagedown功能配置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pageup-pagedown功能配置"}},[t._v("#")]),t._v(" pageup/pagedown功能配置")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('vim  /etc/inputrc\t\n\t#文件存放位置：1，git bash中可以直接找到\t2，资源管理器路径 C:\\Program Files\\Git\\etc\\inputrc\n\t#配置项规则\t\t键：功能（功能关键字都是预置好的，不可修改）\n\t\n\t32   #"\\e[5~": beginning-of-history            # Page up\t\t\t\t\t#默认配置\n \t33   #"\\e[6~": end-of-history                  # Page down\t\t\t\t\t#默认配置\n \t34   #"\\e[5~": previous-history                # Page up\t\t    \t\t#尝试修改成此配置，发现不成效\n \t35   #"\\e[6~": next-history                    # Page down\t     \t\t\t#尝试修改成此配置，发现不成效\n \t36   "\\e[5~": history-search-backward          # Page up\t\t\t\t\t#修改后配置\n \t37   "\\e[6~": history-search-forward           # Page down\t\t\t\t\t#修改后配置\n')])])]),a("h4",{attrs:{id:"alias配置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#alias配置"}},[t._v("#")]),t._v(" "),a("strong",[t._v("alias配置")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('\n[alias]\n\tll = log --oneline --graph\n    mc = "commit -m"\n    \n')])])]),a("h3",{attrs:{id:"git免密登陆"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#git免密登陆"}},[t._v("#")]),t._v(" git免密登陆")]),t._v(" "),a("blockquote",[a("p",[t._v("账号密码登陆的时候，密码处也可以用github端生成的token代替 ！！！！")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("方式一：URL中体现")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("https://用户名:密码@github.com/yulinvo/testProject.git\n\t#git remote add origin https://用户名:密码@github.com/yulinvo/testProject.git  #之后操作就不需要账号密码了\n")])])]),a("ul",[a("li",[a("p",[t._v("https免密登陆")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git config --global credential.helper store\n\n查看.git/config:\n[credential]  \n    helper = store\n")])])])])])]),t._v(" "),a("li",[a("p",[t._v("方式二：SSH实现")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("SSH Key突然失效问题解答及处理办法: https://gitee.com/help/articles/4352#article-header0\n")])])])]),t._v(" "),a("li",[a("p",[t._v("方式三：git自动管理凭证\t\t\t                                                          #P30    09.30")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('window设置--凭据管理器--windows凭据--普通凭据--添加普通凭据：\n\tInternet地址或网络地址：git:https://github.com\n\t用户名：Personal Access Token\t\t\t#应为是自动添加的，这个可能被隐藏了\n\t密码：xx\n\n参考地址：https://www.bilibili.com/video/BV1dq4y117CY?p=38\t#03:00左右\n\t#另: 本节视频中邀请团队成员，可以邮件确认，也可以（在邀请成员的位置点击"Copy invite link"）用被邀请人的账号登录后，直接将邀请链接在浏览器中打开也会跳到邀请的界面\n\t#好像要win来帮忙管理凭据，需要弹出一个对话框"GitHub Login"，在这里输入才能帮助保存凭据；在git命令行中提示输入的用户名、密码是不会被win作为凭据来保存的\n')])])])])]),t._v(" "),a("h3",{attrs:{id:"gitignore忽略文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#gitignore忽略文件"}},[t._v("#")]),t._v(" gitignore忽略文件")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("在gitignore中的文件，git status也不再显示了\t\t\t\t\t\t #P31 02.00左右")])]),t._v(" "),a("li",[a("p",[t._v(".gitignore文件默认是会被管理的\t\t\t\t\t\t\t\t\t\t\t\t#P31 03.20")])]),t._v(" "),a("li",[a("p",[t._v("github上提供的gitignore文件模板：\t\t\t\t\t\t\t\t\t     #P31 05.55")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("#搜索的时候使用'ALL GitHub'选项\n")])])])]),t._v(" "),a("li",[a("p",[t._v(".gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。解决方法:")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git rm -r --cached .\t\t\t\t#把本地缓存删除（改变成未track状态）\ngit ls-files\t#查看暂存区内容\t#查看当前版本管理文件(git add之后就会出现，不管是否commit过都会出现在这里！！！)\n\t#git ls-files -s\n")])])])]),t._v(" "),a("li",[a("p",[t._v("规则：")])])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("以”#”号开头表示注释；\n以斜杠“/”开头表示目录；\n以星号“*”通配多个字符；\n以问号“?”通配单个字符\n以方括号“[]”包含单个字符的匹配列表；\n以叹号“!”表示不忽略(跟踪)匹配到的文件或目录；\n\n** 代表匹配多级目录\t\t\t\t\t\t\t#这个好像没什么用吧，而且这个是对的么？？？\n匹配模式最后跟反斜杠（/）说明要忽略的是目录。\t\t#不管在哪个层级，在根目录和子目录都忽略（好像不用写/也能表示同样意思）\n\nfile\t\t#忽略目录file下的全部内容；不管是根目录下的/file/目录，还是某个子目录/child/file/目录，都会被忽略。\n/file\t\t#忽略根目录下的/file目录的全部内容；\n\n/*\n!.gitignore\t\t#忽略所有文件(好像不用像正则表达式一样用.*表示所有)，但不忽略.gitignore文件。\n\n\n")])])]),a("ul",[a("li",[t._v("vue2创建后自动配置示例：")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v(".DS_Store\nnode_modules\n/dist\n\n.history\n*.py[cz]\nmysite/__pycache__/\nmysite/settings.py\nnote/__pycache__/\nnote/migrations\nvue-note-project/node_modules/\n\n\n# local env files\n.env.local\n.env.*.local\n\n# Log files\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\npnpm-debug.log*\n\n# Editor directories and files\n.idea\n.vscode\n*.suo\n*.ntvs*\n*.njsproj\n*.sln\n*.sw?\n\n")])])]),a("ul",[a("li",[a("strong",[t._v("note项目gitignore示例：")])])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("完整版：\nnode_modules\n.history\n*.py[cz]\nmysite/__pycache__/\nmysite/settings.py\nnote/__pycache__/\nnote/migrations\nvue2_note/node_modules/\n\n精简版:\nnode_modules\n.history\n*.py[cz]\n__pycache__\nmysite/settings.py\nnote/migrations\n")])])]),a("h3",{attrs:{id:"github任务管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#github任务管理"}},[t._v("#")]),t._v(" github任务管理")]),t._v(" "),a("blockquote",[a("p",[t._v("#P32")])]),t._v(" "),a("ul",[a("li",[t._v("issues：文档及Bug管理")]),t._v(" "),a("li",[t._v("wiki：项目介绍，类似于Readme文档")])]),t._v(" "),a("h3",{attrs:{id:"refs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#refs"}},[t._v("#")]),t._v(" refs")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("分支管理的命名空间，如：refs/heads/*, refs/for/refs/heads/*,refs/tags/*\n")])])]),a("h3",{attrs:{id:"reset和revert"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reset和revert"}},[t._v("#")]),t._v(" Reset和Revert")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("#两种回退方式\n\n原则:Gerrit merge之前用reset , merge之后用revert\ngit reset commit-id --hard :回退到指定commit，不留任何痕迹\ngit reset HEAD^\ngit reset master^^\ngit reset HEAD~1\ngit reset master~3\n\ngit revert commit-id -s :回退一次提交，并自动生成一个相反的patch，需审核入库才能生效，类似gerrit上的revert按钮功能\n\tgit revert <name of bad commit>\n\tgit revert HEAD\n")])])]),a("h3",{attrs:{id:"clean和checkout"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#clean和checkout"}},[t._v("#")]),t._v(" Clean和Checkout")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("#清理本地工作目录\n\ngit clean -fd:删除所有未跟踪的文件和目录，清理临时文件利器\ngit checkout --文件名∶把一个文件回退到原始未修改的状态\n")])])]),a("h3",{attrs:{id:"cherry-pick"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cherry-pick"}},[t._v("#")]),t._v(" Cherry-pick")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("#单个/批量合入修改\n\ngit cherry-pick -s -x sha1\t\t#拣选指定提交并合入当前分支\n\t-s∶添加用户签名信息\n\t-x∶添加原始commit shal信息，用于追溯\n\n参考下：https://www.bilibili.com/video/BV1UL411V7f3?p=22\t（视频不一定好，随便找的一个）\n\tgit cherry-pick commitID\t\t#想要对应提交的更改，但是又不想做分支的merge或rebase时\n\n")])])]),a("h3",{attrs:{id:"format-patch和apply-am"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#format-patch和apply-am"}},[t._v("#")]),t._v(" Format-patch和apply ( am )")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("#补丁生成和应用\n\ngit format-path commit-id-..commit-id :\n\t#自动生成patch，如0001-Add-LeTV_X60_20130901_030001.xml.patch\ngit apply patch-name :应用patch\ngit format-patch + git apply =离线版cherry-pick\ngit am patch-name:另一种打patch的方式，可以自动复用commit message\n")])])]),a("h2",{attrs:{id:"git视频二"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#git视频二"}},[t._v("#")]),t._v(" git视频二")]),t._v(" "),a("p",[t._v("参考视频："),a("a",{attrs:{href:"https://www.bilibili.com/video/BV1fq4y1y7Rs?p=6&spm_id_from=pageDriver",target:"_blank",rel:"noopener noreferrer"}},[t._v("玩转Git三剑客_哔哩哔哩_bilibili"),a("OutboundLink")],1)]),t._v(" "),a("h3",{attrs:{id:"p16-变更commit提交信息-非最近一次"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#p16-变更commit提交信息-非最近一次"}},[t._v("#")]),t._v(" #P16 变更commit提交信息（非最近一次）")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git rebase -i commitID（这个commitID是要变更的提交信息，之前一次的提交的id，也就是前一次的）\n\t#里面显示的信息顺序从上到下好像是：从旧的提交--\x3e新的提交\n\t第一行的pick 改为r，wq保存后会弹出一个交互信息框，然后编辑commit信息wq保存退出（不需要第一行有pick）\n\n提交commit信息变更后，commit的ID也变化了，要理解下！！！！\t\t#05.00\n\ttree、blob都没有变化，commit为啥会变化呢？  能想到的原因：提交的commit注释信息也是生成提交ID的一个元素\n\t也有头部分离\n\n注意：如果有tag指向提交，更改提交信息后tag也消失了（git ll查看）！！！！！！\n")])])]),a("h3",{attrs:{id:"p17-将多个连续的commit整理成1个"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#p17-将多个连续的commit整理成1个"}},[t._v("#")]),t._v(" #P17 将多个连续的commit整理成1个")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git rebase -i commitID（这个commitID也是前一次的）\n")])])]),a("h3",{attrs:{id:"p18-将多个间隔的commit整理成1个"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#p18-将多个间隔的commit整理成1个"}},[t._v("#")]),t._v(" #P18 将多个间隔的commit整理成1个")]),t._v(" "),a("blockquote",[a("p",[t._v("重复看下")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("需要将commitID手动添加进去\n\n实际上是手动将commit提交顺序在vim中修改(前后顺序改下)\n\ngitk --all会出现两棵树：注意看中间是有断点的，不是连续的\t\t#06.00\n\n将tag、branch删除后，gitk中显示的用不到的结构就会被git清理掉，要怎么做呢？\t\t#07.00\n")])])]),a("h3",{attrs:{id:"p19-比较暂存区和head所含文件的差异"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#p19-比较暂存区和head所含文件的差异"}},[t._v("#")]),t._v(" #P19 比较暂存区和HEAD所含文件的差异")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git diff --cached\t\t#比较暂存区和HEAD（版本库）之间的差异，如果commitID缺省应该是HEAD\n\t#注意结果和git diff是不同的！！！！！\ngit diff --staged 作用和git diff --cached相同\n")])])]),a("h3",{attrs:{id:"p20-比较工作区和暂存区所含文件的差异"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#p20-比较工作区和暂存区所含文件的差异"}},[t._v("#")]),t._v(" #P20 比较工作区和暂存区所含文件的差异")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('git diff\t\t\t\t\t\t\t#默认情况下（什么都不写）比较的是工作区和暂存区的区别\n\t#文件修改后add，此时再次修改此文件先不提交，此时执行git diff才能看到区别！！！！！！！！！！！！！\ngit diff -- readme.md\t\t\t\t#只比较readme.md文件的差异\ngit diff -- readme.md\tstyle.cc \t#比较readme.md和style.css两个文件的差异\n\ngit diff commitID:\t\t#比较工作区和本地版本库之间的差异  (git diff HEAD)\n\t#等于两条命令之和；"git diff" + "git diff --cached"\n')])])]),a("h3",{attrs:{id:"p21-恢复所有暂存区的内容"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#p21-恢复所有暂存区的内容"}},[t._v("#")]),t._v(" #P21 恢复所有暂存区的内容")]),t._v(" "),a("blockquote",[a("p",[t._v("使用场景：暂存区的内容都不要了，恢复成HEAD指向的内容（和git reset --hard感觉是一个意思吧？？？）")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('git reset HEAD    #后面不加文件名，默认恢复所有的文件\n\n以为新版本的git对应的命令是"git restore --staged"，测试后发现不是，还是上面的命令\n')])])]),a("h3",{attrs:{id:"p22-恢复暂存区的文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#p22-恢复暂存区的文件"}},[t._v("#")]),t._v(" #P22 恢复暂存区的文件！！！！！")]),t._v(" "),a("blockquote",[a("p",[t._v("这一节内容不是太重要，感觉打开了一个思路，对note的尝试性的修改可以放到此处（好像也没什么用，在看下本节视频找找灵感吧）")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git status根据提示命令操作即可\n\ngit diff index.html\t\t#不是要加--么，此处为什么可以什么都不加呢\t\t#03.55\n")])])]),a("p",[t._v("#P23  取消暂存区文件修改")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git reset HEAD -- index.html\t\t#这个也不会回退文件内容，只是取消缓存，文件内容还是以工作区为准！！！！！\ngit restore --staged index.html\t\t\n\t#这个只是将取消暂存文件，文件的内容不会回退！！！！！！！！！\n\t#接上，即文件add后，修改然后restore --staged 文件依然后修改后的状态！！！！！！\n\ngit restore index.html\t\t#在没有add时，使用此命令可以退回文件内容（git status会有此提示命令！！！！）\n")])])]),a("h3",{attrs:{id:"p25-查看不同提交的指定文件的差异"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#p25-查看不同提交的指定文件的差异"}},[t._v("#")]),t._v(" #P25  查看不同提交的指定文件的差异")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git diff temp master -- index.html\t\t#注意01.51的那句话，+-都是master相对于temp分支而言的（后面的对前面的而言）\ngit diff  xx xx -- index.html\t\t#用commit比较（要用分支上最新的commitID），和上面一样\n")])])]),a("p",[t._v("#P26 删除文件")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git rest --hard HEAD\t#01.30\t#这个HEAD应该还是指向Commit，即本地版本库的状态，而不是当前工作区的状态！！！！！！！\n")])])]),a("p",[t._v("#P27 stash")]),t._v(" "),a("p",[t._v("#P28 gitignore")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("*.dsym/  加不加斜杠的区别：\t #文件夹下所有文件都不管理，但是a.dysm是需要管理的（如果*.dsym/没有斜杠，就也不会被管控了）\n\n")])])]),a("h3",{attrs:{id:"p29-git的备份"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#p29-git的备份"}},[t._v("#")]),t._v(" #P29 git的备份")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git clone --bare \t/c/Users/yulinvo/Desktop/temp/git_1635399898/abc123/.git  ya.git\t\t#03.50\n\t#--bare是不带工作区的\n\ngit clone --bare \tfile:///c/Users/yulinvo/Desktop/temp/git_1635399898/abc123/.git  zhineng.git\n\ngit remote add zhineng file:///c/Users/yulinvo/Desktop/temp/git_1635399898/abc123/.git\t\t#06.40\n\t#git push -u zhineng suling (当有两个remotes时，不设置-u，执行git push就不知道要往哪里push了)\n\n\n")])])]),a("p",[t._v("#P32 创建个人仓库")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("勾选license之后（课件中勾选的是MIT License），仓库创建出来会有一个LICENSE文件\n")])])]),a("h3",{attrs:{id:"p33-把本地仓库同步到github"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#p33-把本地仓库同步到github"}},[t._v("#")]),t._v(" #P33 把本地仓库同步到github")]),t._v(" "),a("blockquote",[a("p",[t._v("重复观看")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git push github --all \t\t#04.20\t\t#此时git remote -v有两个远端（github和zhineng）\t！！！！！！！！！！！！\n\ngitk --all查看  \t#05.40\t\t#注意绿色的分支，远程分支也会显示\n\ngit fetch github  master，此时在gitk --all查看又出现了一个独立的树\t\t#手动指定远端（因为本地有两个remote）\t#07.50\n\n远端有文件时，在本地fetch后，git merge github/master会报错，之前遇见过这个错误，好像没有解决，只记得是个大坑：\t#11.00\n\tgit merge --allow-unrelated-histories github/master\n\n这一集要好好看下，主要看点：1，本地已经有git仓库了  2，github上的仓库初始化的时候有一个License文件，注意看下合并后的树的形状，git push github master之后再看下树的形状，github/master已经指向master分支了（而不是initial commit了） #13.00\n")])])]),a("p",[t._v("#P34  不同人修改不同文件")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("创建分支可以是有斜杠的：feature/add_git_commmands  \t\t#01.55\ngit clone git@xxx.git\tnew_name.git\t\t#clone时可以改名  #03.50\n\ngit checkout -b feature/add_git_commmands\torigin/feature/add_git_commmands\t#08.35 \n\t#自己测试时好像不需要远端仓库名（好像自动会根据名称创建，git checkout -b feature/add_git_commmands）\n\t#接上，git branch feature/add_git_commmands 好像是不行吧，回头测试下\n\t\n\ngit push 本地分支  远端分支\t\t#关于本地分支名称、远端分支名称的关系可以再看下\n\ngit push -f\t\t\t#19.20\n")])])]),a("p",[t._v("#P39  禁止向集成分支执行push -f操作")]),t._v(" "),a("p",[t._v("#P40 禁止向集成分支执行变更历史的操作")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("公共分支禁止执行rebase变基的操作\t\t\t#00.10\n\ngit rebase 之后不能git reset --hard xx 返回了么？？？\n")])])]),a("p",[t._v("#P43 github搜索技巧")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("in:readme\nstars:>1000\n搜索代码片段\n\n")])])]),a("p",[t._v("#P44  在github上搭建个人博客")]),t._v(" "),a("p",[t._v("#P46 github上的组织")])])}),[],!1,null,null,null);a.default=i.exports}}]);