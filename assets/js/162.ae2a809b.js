(window.webpackJsonp=window.webpackJsonp||[]).push([[162],{430:function(t,a,e){"use strict";e.r(a);var n=e(13),s=Object(n.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"文件读取模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#文件读取模式"}},[t._v("#")]),t._v(" 文件读取模式")]),t._v(" "),a("p",[a("strong",[t._v("打开文件的模式有：")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("r:只读（默认）\nw:只写（不可读、不存在则创建、存在则删除内容）\na:追加（可读、不存在则创建、存在则只追加内容）\n")])])]),a("p",[a("strong",[t._v("+表示可同时读写某个文件")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("r+:可读写文件（可读、可写、可追加）\nw+:写读\na+:同a，没什么意义\n")])])]),a("p",[t._v("**U表示在读取时，可以将\\r \\n \\r\\n自动转换成\\n ** (与r或r+模式同时使用)   #windos是\\r换行，linux是\\n换行？？？")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("rU\nr+U\n写的时候使用'U'时，也可以将\\r \\n \\r\\n自动转换成\\n\n")])])]),a("p",[a("strong",[t._v("b表示处理二进制文件")]),t._v("(如：FTP发送上传ISO镜像文件，LINUX可忽略，windows处理二进制文件时需标注)")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("rb\nwb\nab\n\nLINUX虽然已经把所有东西都当成文件了，为什么对linux就形同虚设，linux上不是还有bin文件么？？？\n")])])]),a("h2",{attrs:{id:"文件常用属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#文件常用属性"}},[t._v("#")]),t._v(" 文件常用属性")]),t._v(" "),a("p",[t._v("f= open('./aaa.cfg','r')")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("f.fileno() ：\t\t\t\t#文件描述符，相当于文件句柄\nf.flush：\t\t\t\t\t#刷新文件内部缓冲区，将文件从内存中写入硬盘\nf.isatty：\t\t\t\t\t#判断文件是否是同意tty设备，没什么用\nf.read(n):\t\t\t\t\t #读取n个字节  \n\t\t读取中文时f.read(2)会显示乱码，因为一个中文字符占用三个字节，f.read(3)就显示正常\n        在python3.x里面是按照字符读取的，不是按照字节读取的，f.read(1)就能读取出第一个字符\n\nf.readable:是否可读\nf.writable:是否可写\nf.readline:读取一行\n\nf.seek:指定指针所处的位置\n\tf=open('123.py','r');f.seeK(1);f.read()    #从指针1开始读默认是0，如果是中文字符开头的就会有乱码（中文字符占3byte）\n\nf.tell:查看当前指针所在位置\n\tf=open('123.py','r')\n\tprint f.tell()               #还没开始读文件时，指针所处的位置，为0\n\tf.readline();print f.tell();f.readline();print f.tell()     #每次读取后指针的位置会变化\n\tf.read();print f.tell()     #文件全部读取完成后，指针所处的位置\n    也可以这样测试：f.read(2);print f.tell()     #3.x需要注意一点：read(2)按照字符，tell()是读取相应字节后指针所在的位置\n\n\nf.truncate: 截断数据，仅保留指定之前的数据，笔记f.seek()例子中只读取指针之后的数据；这两个一个读之后的数据，一个读之前的数据\n       f.seek(5);f.truncate()执行之后直接会修改源文件，保留了前5个字符\n       （1，记得f.close()  2,测试的时候使用英文字母，一个字母一个byte）\n")])])]),a("h2",{attrs:{id:"文件读取"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#文件读取"}},[t._v("#")]),t._v(" 文件读取")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("f=open('aa.py','w')\t\t\t\t\t#w模式会清空原文件的内容！！！！\nf.readline()\nf.write('xx')\nf.flush()                       #和close类似，但当不想close时，只是查看目前写入的数据，可以使用flush\nf.close()\n\n")])])]),a("p",[a("strong",[t._v("这种方式读取更优")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("f=open('123')\nfor line in f:     #使用此方式读取(好像也是通过迭代方式，同迭代器)，循环好像很少使用f.readlines()或是f.read()\n     #建议用这种方式，不要使用f.read(),f.readlines()，这样不会把整个文件都加载到内存(如果文件很大就看到区别了)\n     \n     print line,     \t#每print一次，类似与调用一次iter中的next方法\n")])])]),a("h2",{attrs:{id:"上下文操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#上下文操作"}},[t._v("#")]),t._v(" 上下文操作")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("with open('abc.txt','w') as f:\n\tf.write('123')\n\t\nwith open('log1') as obj1,open('log2') as obj2:\t\t\t#同时读取多个文件\n\tpass\n")])])])])}),[],!1,null,null,null);a.default=s.exports}}]);