(window.webpackJsonp=window.webpackJsonp||[]).push([[161],{429:function(a,t,n){"use strict";n.r(t);var e=n(13),_=Object(e.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"模块引入"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#模块引入"}},[a._v("#")]),a._v(" 模块引入")]),a._v(" "),t("p",[a._v("模块引入方式：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("方式一： 引入整个模块\n\timport  demo   &&  print(demo.age)   或者  import  demo  as do &&  print(do.age)\n\n方式二： 只引入模块中的部分方法\n\t from demo import age \t或者\t from demo import age as age111\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("#cat aa.py:\n    __all__ = ['add',]\t\t# noqa (加上这个好像是语法不检查还是什么)       \n        #控制模块对外接口,不是强制性的！！！！\n        -\tfrom aa import *只会引入add，可以在ipython中执行dir()查看环境变量中的内容有没有say \n        -\t但是from module import  say依然可以引用\n        -\t但是import aa，依然可以使用module.say()\n\n    def _say():    print('111')\t\t\n        #一个下划线开头的函数是模块私有的，不希望被外部调用，但是也不是强制的，外部依然可以调用，君子协定\n\n    def say():    print('say...12')\n    def add(a,b):    return a+b\n\n    if __name__ == \"__main__\":    say()\t\t\t#直接执行import aa时不会输出‘say...12'\n\n\nimport aa\t&&\taa.__xx\t\t\t\t#aa.__\t使用tab查看都有哪些方法\t\t#直接在ipython中import aa即可！！！\n​\t#aa.__name__\t   \t输出str格式结果，'aa'，__name__是一个方法，直接执行__name__输出的是__main__\n​\t#aa.__file__\t\t\n")])])]),t("h2",{attrs:{id:"包的引入"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#包的引入"}},[a._v("#")]),a._v(" 包的引入")]),a._v(" "),t("blockquote",[t("p",[t("em",[a._v("_init")]),a._v('_.py文件：当引入一个包的变量或方法时，默认就会先执行__init__.py中代码，比如aa包的init语句中有一个print("引入aa包中的模块...")语句，import aa时就会先输出这一句')]),a._v(" "),t("p",[t("em",[a._v("_init")]),a._v("_.py文件中的变量、函数都属于是包的，比如init文件中写入一个def func1():pass，可以：1，import aa && aa.func1()调用  2，from aa import func1调用     ！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！")]),a._v(" "),t("p",[a._v("from aa.xx 这种写法，点后面的xx只能是包名（即使在__init__中引入了也不行）【也是，"),t("em",[a._v("_init")]),a._v("_中定义的内容就相当于是包自身的属性了，当然可以直接调取，不用再次导入了】；from aa import xx这样可以直接引入__init__中定义的内容 ！！！！！")]),a._v(" "),t("p",[a._v("from django.http import request\t#http是包，则request  1：要么是包下面的模块，2：要么是__init__.py中引入的快捷方式！！！")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('目录结构：\n+--- 01.py\t\t\t\t\t#文件内容为空\n+--- aa\n|   +--- __init__.py\t\t#文件中只有一行代码：\tprint("引入aa包中的模块...")\n|   +--- a1.py\t\t\t\t#文件中只有一行代码： name1 = "a1"\n|   +--- a2.py\t\t\t\t#文件中只有一行代码： name2 = "a2"\n')])])]),t("ol",[t("li",[t("p",[a._v("在01.py中引入aa/a2.py中的name2变量，执行的是01.py文件，这个是期望的结果没有问题")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("$ cat 01.py\n\tfrom aa.a2 import name2\t\t\t\n\t\t#注意这句代码的执行顺序：1，先执行包的__init__.py  2，执行a2中的全部代码  ！！！！！！！！！！！！\n\t\t#接上，即使这段代码是写在包的__init__.py文件中的，也会执行a2中的全部代码  ！！！！！！！！！！！！\n\tprint(name2)\n\n# 执行结果为：\n\t引入aa包中的模块...\n\ta2\n")])])])]),a._v(" "),t("li",[t("p",[a._v("01.py文件内容和上面的内容保持不变，")]),a._v(" "),t("ul",[t("li",[t("p",[a._v('在aa/a2.py中引入aa/a1.py的name1变量，当执行的是a2.py文件时正常输出"a1"')]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("$ cat a2.py\n\tname2 = \"a2\"\n\tfrom a1 import name1\t\t\t#此时a1是包还是模块呢？？？ 注意此时a1和.a1是由区别的\n\t#.a1是相对目录；a1是模块，报错是显示：ModuleNotFoundError: No module named 'a1' ！！！！！！！！！！!!!!!!\n\tprint(name1)\n")])])])]),a._v(" "),t("li",[t("p",[a._v("接上，但是当执行01.py文件时，期望输出的结果为")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("引入aa包中的模块...\na1\na2\n\n但是执行结果报错：（a2.py） ModuleNotFoundError: No module named 'a1'\n\n此时：\n\t-. 将aa/a2.py中的内容由“from a1 import name1” 改为 “from aa.a1 import name1”就能正常输出了，为啥？？？\n为什么 包内部的同级文件间导入，也需要通过包名绕一下？？？\n\t-. 将aa/a2.py中的内容由“from a1 import name1” 改为 “from .a1 import name1”也能正常输出了\n----------------------------------------------------------------------------------------\na2.py中整个模块导入时：import aa.a1 && print(aa.a1.name1)\t\t\t#模块整体导入！！！！！\n")])])])])])])]),a._v(" "),t("h2",{attrs:{id:"相对引入"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#相对引入"}},[a._v("#")]),a._v(" 相对引入")]),a._v(" "),t("blockquote",[t("p",[a._v("绝对引入时是通过sys.path查找路径；")]),a._v(" "),t("p",[a._v("相对引入也需要先使用sys.path找到py文件所属于的包（不过要先告诉解释器文件所属于的包是哪个） ！！！！！！！！！！")]),a._v(" "),t("p",[a._v("参考文档："),t("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/145903888",target:"_blank",rel:"noopener noreferrer"}},[a._v("Python 中的绝对导入和相对导入 - 知乎 (zhihu.com)"),t("OutboundLink")],1)]),a._v(" "),t("p",[a._v("​\t\t\t\t\t"),t("a",{attrs:{href:"https://www.bilibili.com/video/BV1EK411g7Ff?from=search&seid=1673769137031295504&spm_id_from=333.337.0.0",target:"_blank",rel:"noopener noreferrer"}},[a._v("python import中的绝对引用和相对引用_哔哩哔哩_bilibili"),t("OutboundLink")],1)])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('目录结构：\n+--- aa\n|   +--- __init__.py\t\t#文件中只有一行代码：\tprint("引入aa包中的模块...")\n|   +--- a1.py\t\t\t\t#文件中只有一行代码： name1 = "a1"\n|   +--- a2.py\t\t\t\t#文件中只有一行代码： name2 = "a2"\n')])])]),t("p",[a._v('a1.py中代码"from . import a2"执行时报错"ImportError: attempted relative import with no known parent package"；这个跟是否是顶层目录没有关系，aa下在建一层bb，下两个文件b1.py/b2.py结构和内容类似上面，依然是报同样的错误，说明跟目录深度没有关系；但是子包之间通过相对引用时，通过主程序来运行的话是没有问题的（B站参考视频的13.00左右），因为子包被调用时__package__和__name__是有正确的值的，'),t("em",[a._v("_init")]),a._v("_能使用相对路径引入也是这个道理！！！！！！！")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("a2.py中添加打印语句：\n\tprint('__file__={0:<35} | __name__={1:<20} | __package__={2:<20}'.format(\n    __file__, __name__, str(__package__)))\n\na1.py中添加代码：\n\tsys.path.append('c:\\\\Users\\\\yulinvo\\\\Desktop\\\\temp\\\\python3_1634879321\\\\code0001')\t\n\t\t#要先能找到上层包aa\n\t\t#sys.path.append只是程序执行时临时加进去，执行结束后就自动释放了，测试：单独在a2.py中打印sys.path就没有这个路径\n\t\n\t__package__ = 'aa'\t\t\t#__name__和__package__使用任意一个即可\n\t\t#如果 __package__ 为 None 表示该模块是顶层模块！！！！！！！！！！！！\n\t# __name__ = 'aa.xx'\t\t#__name__和__package__使用任意一个即可\n\tfrom . import a2\t\t\t#这样就能正常引入了\n\t\n\t\na1.py中代码执行后输出结果：\n\t\t引入aa包中的模块...\n\t\t__file__=c:\\Users\\...\\code0001\\aa\\a2.py | __name__=aa.a2    | __package__=aa\n")])])]),t("h2",{attrs:{id:"包的制作、安装、删除"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#包的制作、安装、删除"}},[a._v("#")]),a._v(" 包的制作、安装、删除")]),a._v(" "),t("ol",[t("li",[t("p",[a._v("目录结构")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('目录解构：\n+--- aa\n|   +--- __init__.py\t\t#文件中只有一行代码：\tprint("引入aa包中的模块...")\n|   +--- a1.py\t\t\t\t#文件中只有一行代码： name1 = "a1"\n|   +--- a2.py\t\t\t\t#文件中只有一行代码： name2 = "a2"\n+--- setup.py\t\t\t\t\t#文件内容为空\n')])])]),t("ul",[t("li",[t("p",[a._v("setup.py内容")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('from setuptools import setup, find_packages\t\t#如果是这种写法，配合packages=find_packages()\n# from distutils.core import setup\t\t\t\t#如果是这种写法，配合下面的py_modules=[...]\n\n\nsetup(\n    name="aaa01",\n    version="1.0",\n    description="aa test module",\n    long_description="aa test module ---------",\n    author="yulinvo",                         # your name\n    author_email="yulinvo@163.cn",    # your email\n    url="https://yulinvo.cn",          # your module home page, such as\n    # py_modules=["aaa01.a1","aaa01.a2"]     #这一句必须要写，否则build的结果为空，同样的执行sdist的结果也为空\n\n    # license="MIT",\n    packages=find_packages(),\n    # include_package_data=True,\n    # platforms="any",\n    # install_requires=[]\n)\n\n')])])])])])]),a._v(" "),t("li",[t("p",[a._v("制作包")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("方式一：from setuptools import setup, find_packages\t（推荐）\n    参考文档：http://zhongjiajie.com/2017/10/21/pypi安装包制作及发布/\n\n    python setup.py sdist       # 生成二进制包 支持pip安装 推荐使用\n    python setup.py bdist_egg   # 生成egg 支持easy_install安装\n\n\n方式二：from distutils.core import setup\n    参考文档：https://www.bilibili.com/video/BV1ex411x7Em?p=442\n\n    #python setup.py build \t\t\t\t\t#构建模块\n    #python setup.py sdist\t\t\t\t\t#生成发布压缩包\n\n")])])])]),a._v(" "),t("li",[t("p",[a._v("安装包")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("方式一：\t对应制作包的方式一\n\tpip install sdist/xxx.tar.gz\n\n方式二：\t对应制作包的方式二\n\ttar -zxvf xx.tar.gz  &&  python setup.py install\n\t或者：pip install aaa01-1.0.tar.gz\n")])])])]),a._v(" "),t("li",[t("p",[a._v("上传到pypi")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("上传到pypi没有测试，\n\n参考链接：\n\t参考下上面链接：http://zhongjiajie.com/2017/10/21/pypi安装包制作及发布/\n\t或者：https://docs.djangoproject.com/zh-hans/2.1/intro/reusable-apps/\n")])])])]),a._v(" "),t("li",[t("p",[a._v("删除包")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("直接将磁盘文件删除即可：\n\t#cd  ${workdir}\\python3_1634879321\\Lib\\site-packages\\\t#可以在ipython中 aaa01.__file__查看\n\t#rm -rf aaa01\n\t#rm -rf aaa01-1.0-py3.9.egg-info\n")])])])])])])}),[],!1,null,null,null);t.default=_.exports}}]);