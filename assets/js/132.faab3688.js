(window.webpackJsonp=window.webpackJsonp||[]).push([[132],{400:function(n,e,t){"use strict";t.r(e);var a=t(13),r=Object(a.a)({},(function(){var n=this,e=n._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h2",{attrs:{id:"发送邮件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#发送邮件"}},[n._v("#")]),n._v(" 发送邮件")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("#coding:utf-8\nimport  smtplib\nfrom  email.mime.text import  MIMEText\nfrom email.utils import formataddr\n\ndef mail():\n    ret=True\n    try:\n        msg=MIMEText('邮件内容','plain','utf-8')\n        msg['From'] = formataddr(['邮箱标识','zhangwanit@163.com'])\n        msg['To'] = formataddr(['雨林','729100483@qq.com'])\n        msg['Subject'] = '邮件主题'\n\n        server = smtplib.SMTP('smtp.163.com',25)\n        server.login('zhangwanit@163.com','zhangwanit163')\n        server.sendmail('zhangwanit@163.com',['729100483@qq.com','zhangwanit@163.com'],msg.as_string())\n        server.quit()\n    except Exception:\n        ret=False\n    return ret\n\nret=mail()\nif ret:\n    print '发送成功'\nelse:\n    print '发送失败'\n\n\n******************************************************************************************************************************************************\n******************************************************************************************************************************************************\n******************************************************************************************************************************************************\n\n\n#coding:utf-8\nimport  smtplib\nfrom  email.mime.text import  MIMEText\nfrom email.utils import formataddr\n\ndef mail(user1,user2,mailtext):               #形参\n    ret=True\n    try:\n        msg=MIMEText(mailtext,'plain','utf-8')\n        msg['From'] = formataddr(['邮箱标识','zhangwanit@163.com'])\n        msg['To'] = formataddr(['雨林','729100483@qq.com'])\n        msg['Subject'] = '邮件主题'\n\n        server = smtplib.SMTP('smtp.163.com',25)\n        server.login('zhangwanit@163.com','zhangwanit163')\n        server.sendmail('zhangwanit@163.com',[user1,user2],msg.as_string())               #此处虽然有两个接受者，但是是单独发的，在收件人里彼此看不到\n        server.quit()\n    except Exception:\n        ret=False\n    return ret\n\nret=mail('729100483@qq.com','shanhuifu1222@163.com','这是邮件正文')          #实参\nif ret:\n    print '发送成功'\nelse:\n    print '发送失败'\n")])])]),e("h2",{attrs:{id:"get-进程id"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#get-进程id"}},[n._v("#")]),n._v(" get 进程id")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("__author__ = \"Alex Li\"\nfrom multiprocessing import Process\nimport os\ndef info(title):\n    print(title)\n    print('module name:', __name__)\n    print('parent process:', os.getppid())\n    print('process id:', os.getpid())\n    print(\"\\n\\n\")\ndef f(name):\n    info('\\033[31;1mcalled from child process function f\\033[0m')\n    print('hello', name)\nif __name__ == '__main__':\n    info('\\033[32;1mmain process line\\033[0m')\n    p = Process(target=f, args=('bob',))\n    p.start()\n    # p.join()\n")])])]),e("h2",{attrs:{id:"计算50个子线程全部执行完需要的时间"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#计算50个子线程全部执行完需要的时间"}},[n._v("#")]),n._v(" 计算50个子线程全部执行完需要的时间")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("#coding:utf-8\nimport threading,time\ndef run(n):\n    print 'task',n\n    time.sleep(2)\n    print 'task_done',n\nstart_time = time.time()\nt_obj= []\nfor i in  range(50):\n    t = threading.Thread(target=run,args=('t-%s' %i,))\n  t.setDaemon(True) #将当前线程设置为守护线程，一定要在start之前设置    守护线程的意思是当主线程结束后，子线程也强制结束了，效果是加上这句后fun函数里的print 'task_done',不会执行了\n    t.start()                   #子线程执行完run函数后就退出了，不会一直挂着\n#t.join()               #此时t是最后的i为49的时候的t，为什么t能从for循环传递出来呢？？？  原因：函数执行完变量就释放了，但此处是循环不是函数，执行完后变量不会释放\n    t_obj.append(t)\nprint 't_onj:' ,t_obj\nfor t in t_obj:\n    t.join()             #子线程没有执行完之前，主线程会卡住；在此处的意思是50个子线程全部执行完后，才执行主线程后面的代码\nprint 'cost:',time.time() - start_time ,threading.current_thread(),threading.active_count()         #这里不会得到所有子进程执行完函数run后一共用了多少时间，得到的是启动完所有子线程用的时间，线程和子线程之间是独立的，threading.current_thread()为当前进程所在位置（主线程会提示_MainThread(MainThread），threading.active_count()是统计当前活跃的进程个数\n")])])]),e("h2",{attrs:{id:"红绿灯模拟"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#红绿灯模拟"}},[n._v("#")]),n._v(" 红绿灯模拟")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("#coding:utf-8\nimport  threading,time\nevent = threading.Event()\ndef lighter():\n    count = 0\n    event.set()         #先设置绿灯\n    while True:\n        if count > 5 and count < 10:        #改为红灯\n            event.clear()                    #把标志位清了\n            print '\\033[41;1m red light is on...\\033[0m'\n        elif count > 10:\n            event.set()                      #变绿灯\n            count = 0\n        else:\n            print '\\033[42;1m green light is on...\\033[0m'\n        time.sleep(1)\n        count += 1\ndef car(name):\n    while True:\n        if event.is_set():          #代表绿灯，\n            print '[%s] running...'%name\n            time.sleep(1)\n        else:\n            print '[%s] sees red light ,waiting...'% name\n            event.wait()\n            print '\\033[34;1m [%s] green light is on,start going... \\033[0m'% name\nlight = threading.Thread(target=lighter,)\nlight.start()\n\ncar1 = threading.Thread(target=car,args=('Tesla'),)\ncar1.start()\n")])])]),e("h2",{attrs:{id:"sockserver"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#sockserver"}},[n._v("#")]),n._v(" sockserver")]),n._v(" "),e("p",[e("strong",[n._v("server端")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("#coding:utf-8\nimport SocketServer,socket\nclass MyTCPHandle(SocketServer.BaseRequestHandler):\n    def handle(self):                       #跟客户端所有的交互过程都是handle函数处理的\n        while True:\n            try:\n                self.data = self.request.recv(1024).strip()       # self.request：客户端每一个请求过来都会MyTCPHandle实例化; 客户端不传递数据 recv就在这等着，等待时默认是阻塞的\n                print '{} wrote:'.format(self.client_address[0])            # self.client_address[0] 客户端的ip地址\n                print self.data\n                if not self.data:                   #客户端不是不传了，不传了会阻塞在self.request.recv(1024).strip，没有阻塞又收到的数据是空 表示断开了\n                    print '客户端已断开'\n                    break                           # break这个实例就被释放了\n                self.request.sendall(str(self.data.upper()))   # sendall重复调用send，此处也可以使用send\n            except Exception as e:\n                print 'err:',e\n                break\nif __name__ == '__main__':\n    HOST,PORT = 'localhost',9999\n    server = SocketServer.TCPServer((HOST,PORT),MyTCPHandle)\n    # server = SocketServer.ThreadingTCPServer((HOST,PORT),MyTCPHandle)                #多线程\n    # server = SocketServer.ForkingTCPServer((HOST,PORT),MyTCPHandle)             #多进程（winodws上有点问题，linux上没问题）\n    server.serve_forever()                         # 这个可以同时处理多个请求，多线程？？？\n")])])]),e("p",[e("strong",[n._v("client端")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("#coding:utf-8\nimport socket\nclient = socket.socket(socket.AF_INET,socket.SOCK_STREAM)\nclient.connect(('localhost',9999))\nwhile True:\n    cmd = raw_input('>>>:')\n    if len(cmd) == 0: continue\n    client.send(str(cmd))\n    data = client.recv(1024)\n    print data\nclient.close()\n")])])]),e("h2",{attrs:{id:"socket-编程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#socket-编程"}},[n._v("#")]),n._v(" socket 编程")]),n._v(" "),e("p",[e("strong",[n._v("server 端")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("#coding:utf-8\nimport socket,os\nserver = socket.socket()\nserver.bind(('localhost',9999))\nserver.listen(5)\n\nwhile True:\nconn,addr = server.accept()\nprint 'New Conn :',addr\nwhile True:\nprint '等待新指令'\ndata = conn.recv(1024)\nif not data:\nprint '客户端已断开'\nbreak\nprint '执行指令：',data\ncmd_res = os.popen(data.decode()).read()\nprint 'before send :',len(cmd_res)\nif len(cmd_res) == 0:\ncmd_res = 'cmd has no output...'\nconn.send( str(len(cmd_res.encode())).encode('utf-8') )\n#time.sleep(0.5)                #防止粘包，上下的2个send因为是立即执行，（缓存区没满的时候）会被当成一个包发送过去\nclient_ack = conn.recv(1024)                  #防止粘包的解决方法，等待客户端确认\nconn.send(cmd_res.encode('utf-8'))\nprint 'send done'\n\nserver.close()\n")])])]),e("p",[e("strong",[n._v("client 端")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("#coding:utf-8\nimport socket\nclient = socket.socket()\nclient.connect(('localhost',9999))\n\nwhile True:\ncmd = raw_input('>>>:').strip()\nif len(cmd) == 0:continue\nclient.send(cmd.encode('utf-8'))\ncmd_res_size = client.recv(1024)\nprint '命令结果大小：',cmd_res_size\nclient.send('准备好接收数据'.encode('utf-8'))\n\nreceived_size = 0\nreceived_data = b''\nwhile received_size < int(cmd_res_size.decode()):\ndata = client.recv(1024)\nreceived_size += len(data)\nreceived_data += data\nelse:\nprint 'cmd res received done ...',received_size\nprint received_data.decode()\nclient.close()\n\n")])])]),e("h2",{attrs:{id:"模拟进度条"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模拟进度条"}},[n._v("#")]),n._v(" 模拟进度条")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("import  sys\nimport time\n\nfor i in range(10):\n    sys.stdout.write('#')\n    sys.stdout.flush()              #新版本的好像不用这条命令也可以，老版本的好像是全部写到内存后在一次行输出到前端\n    time.sleep(0.5)\n")])])]),e("h2",{attrs:{id:"生成4位包含字母的动态验证码"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#生成4位包含字母的动态验证码"}},[n._v("#")]),n._v(" 生成4位包含字母的动态验证码")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("import  random\ncheckcode=''\nfor i in range(4):\n    current=random.randrange(0,4)\n    if current != i:\n        temp=chr(random.randint(65,90))\n    else:\n        temp=random.randint(0,9)\n    checkcode += str(temp)\nprint checkcode\n")])])]),e("h2",{attrs:{id:"冒泡排序法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#冒泡排序法"}},[n._v("#")]),n._v(" 冒泡排序法")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("data=[10,4,33,21,54,3,8,11,5,22,2,1,17,13,6]\n\ni=0\ntmp=''\nwhile i < len(data)-1:\n    j=i+1\n    while  j<len(data):\n        if data[i] >data[j]:\n            tmp=data[i]\n            data[i]=data[j]\n            data[j]=tmp\n        j += 1\n    i += 1\nprint data\n")])])]),e("h2",{attrs:{id:"列表旋转90度"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#列表旋转90度"}},[n._v("#")]),n._v(" 列表旋转90度")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("a= [[i for i in range(4)] for j in range(4)]\nprint len(a)\nfor i in range(len(a)):\n    b=[a[i][i] for row in range(4)]\n    print b\n")])])]),e("h2",{attrs:{id:"yield练习"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#yield练习"}},[n._v("#")]),n._v(" yield练习")]),n._v(" "),e("p",[n._v("简单的模拟ATM过程（每次固定取出100元）")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("def cash_money(amount):\n    while amount > 0:\n        amount -= 100\n        yield 100               #执行到yield程序就中断执行了，100是执行atm.next()时返回100,接收值通过别人的send方法\n        print '又来取钱了！'\n\natm=cash_money(500)     #atm是一个生成器，\nprint type(atm)          #输出结果：<type 'generator'> ,而type(cash_money)只是一个普通函数<type 'function'>\nprint atm.next()         #实际环境中好像不太常用print next这种吧，感觉没什么用：1，需要上面yield返回  2，返回固定的值\nprint atm.next()\nprint atm.next()\nprint '出去看电影！'     #实现异步,保存函数执行过程中的中断状态,随便跳出、跳入上面的while循环\nprint atm.next()\nprint atm.next()\n")])])]),e("p",[n._v("手工指定每次取出多少")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("#coding:utf-8\nimport  time\n\ndef cash_money(amount):\n    zonghe=0\n    while amount-zonghe > 0:\n        duoshao = yield\n        # amount -= 100\n        zonghe += duoshao\n        print 'quchu %s yuan ,shengyu %s'% (duoshao,amount-zonghe)\n\natm=cash_money(1000)\natm.next()\n# atm.next()\n\natm.send(100)\natm.send(200)\natm.send(300)\natm.send(50)\n")])])]),e("h2",{attrs:{id:"使用yield实现单线程中的异步并发效果"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用yield实现单线程中的异步并发效果"}},[n._v("#")]),n._v(" 使用yield实现单线程中的异步并发效果")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("#coding:utf-8\nimport  time\ndef consumer(name):\n    print '%s 准备吃包子了!' %name\n    while True:                    #为什么需要一个死循环？？？\n        baozi = yield 100          #实际没有100，但是加上100 如果不执行print c1.next()或是c2.next()看不出区别来\n        print '包子【%s】来了，被【%s】吃了！'%(baozi,name)     #不加()提示TypeError: not enough arguments for format string\n\ndef produce(name):\n    c1=consumer('A')\n    c2=consumer('B')\n    c1.next()\n    c2.next()\n    c1.next()\n    c2.next()\n    print \"老子开始准备做包子了！\"\n    for i in range(3):\n        time.sleep(1)\n        print \"做了2个包子！\"\n        c1.send(i)               #不光是next()可以中断，send()也可以中断\n        c2.send(i)\n\nproduce('alex ')\n")])])]),e("h2",{attrs:{id:"str的format方法-args-kwargs"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#str的format方法-args-kwargs"}},[n._v("#")]),n._v(" str的format方法（*args,**kwargs）")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("name='{0} is {1} years old!'\n\nxx=['tom',19]\n\n\nprint name.format(xx)     #会提示错误IndexError: tuple index out of range，原因是['tom',19]作为tuple的一个参数\nprint name.format(*xx)     #\n\n\n\nname='{0} is {1} years old!'\nxx=['tom',19]\n#print name.format('tom',19)          #按照顺序赋值给{0}，{1}\nprint name.format(*xx)\n\n\nname='{name} is {age} old!'          #传递字典的时候，此处不能使用0、1，要使用key\nd={'name':'jim','age':19}\nprint name.format(**d)\n# print name.format(name='jim',age='19')      #这个有点类似指定参数赋值\n")])])]),e("h2",{attrs:{id:"深拷贝与浅拷贝"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#深拷贝与浅拷贝"}},[n._v("#")]),n._v(" 深拷贝与浅拷贝")]),n._v(" "),e("p",[n._v("现有dic模板如下（里面有很多数据，此处只列出3条），有5K台设备使用此模板")]),n._v(" "),e("p",[n._v("需求：现有一批新设备，cpu的监控项为50，因监控项太多，需要直接copy原来模板，源模板不能改变")]),n._v(" "),e("p",[n._v("dic={")]),n._v(" "),e("p",[n._v("'cpu':[80,],")]),n._v(" "),e("p",[n._v("'mem':[80,],")]),n._v(" "),e("p",[n._v("'disk':[80,]")]),n._v(" "),e("p",[n._v("}")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("import copy\n\ndic={\n    'cpu':[80,],\n    'mem':[80,],\n    'disk':[80,]\n}\nprint \"before\",dic\n# dic_new=copy.copy(dic)          #浅拷贝后修改dic_new源模板也变了\ndic_new=copy.deepcopy(dic)          #深拷贝后修改dic_new源模板不变\ndic_new['cpu'][0]=50\nprint dic\nprint dic_new\n")])])]),e("h2",{attrs:{id:"寻找差异"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#寻找差异"}},[n._v("#")]),n._v(" 寻找差异")]),n._v(" "),e("p",[n._v("数据库中原有：\nold_dict={\n'#1':{'hostname':'c1','cpu_count':2,'mem_capicity':80},\n'#2':{'hostname':'c1','cpu_count':2,'mem_capicity':80},\n'#3':{'hostname':'c1','cpu_count':2,'mem_capicity':80}\n}\nnew_dict={\n'#1':{'hostname':'c1','cpu_count':2,'mem_capicity':800},\n'#3':{'hostname':'c1','cpu_count':2,'mem_capicity':80},\n'#4':{'hostname':'c1','cpu_count':2,'mem_capicity':80}\n}")]),n._v(" "),e("p",[n._v("代码如下：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("修改old_dict中的值，使其和最新的保持一致：\nold_dict={\n    '#1':{'hostname':'c1','cpu_count':2,'mem_capicity':80},\n    '#2':{'hostname':'c1','cpu_count':2,'mem_capicity':80},\n    '#3':{'hostname':'c1','cpu_count':2,'mem_capicity':80}\n}\nnew_dict={\n    '#1':{'hostname':'c1','cpu_count':2,'mem_capicity':800},\n    '#3':{'hostname':'c1','cpu_count':2,'mem_capicity':80},\n    '#4':{'hostname':'c1','cpu_count':2,'mem_capicity':80}\n}\nold_keys= set(old_dict.keys())\nnew_keys=set(new_dict.keys())\n\nupdate_set=old_keys.intersection(new_keys)\ndelete_set=old_keys.symmetric_difference(update_set)\nadd_set=new_keys.symmetric_difference(update_set)\nfor i in update_set:\n    old_dict[i]=new_dict[i]\nfor i in delete_set:\n    old_dict.pop(i)\nfor i in add_set:\n    old_dict[i]=new_dict[i]\nprint old_dict\n\n\n\n如果要做精细的判断，大致思路如下：\nprint old_dict['#1'].keys()\nold_dict['#1']['mem_capicity'] == new_dict['#1']['mem_capicity']\n")])])]),e("h2",{attrs:{id:"菲波那切数列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#菲波那切数列"}},[n._v("#")]),n._v(" 菲波那切数列")]),n._v(" "),e("p",[n._v("菲波那切数列：")]),n._v(" "),e("p",[n._v("0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("#coding:utf-8\n\ndef func(arg1,arg2):\n    if arg1==0:\n        print  arg1,arg2,\n    arg3=arg1+arg2\n    print  arg3,\n    if arg3 <= 100000:     #不加会报错，超出递归的范围\n        func(arg2,arg3)\n\nfunc(0,1)\n")])])]),e("h2",{attrs:{id:"dict字典练习"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dict字典练习"}},[n._v("#")]),n._v(" dict字典练习")]),n._v(" "),e("p",[n._v("需求：将[11,22,33,44,55,66,77,99,90] 元素大于66的放到字典的k2中，小于66的放到字典的k1中")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("方法一：\ndic={}\nlist=[11,22,33,44,55,66,77,99,90]\nlist1=[]\nlist2=[]\nfor i in list:\n    if i <=66:\n        list1.append(i)\n    else:\n        list2.append(i)\n#更新列表的方法一\n# dic.update({'k1':list1})\n# dic.update({'k2':list2})\n\n#更新列表的方法二\n# dic.setdefault('k1',list1)\n# dic.setdefault('k2',list2)\n\n#更新列表的方法三L\n# dic['k1']=list1\n# dic['k2']=list2\nprint dic\n\n方法二：\ndic={}\nlist=[11,22,33,44,55,66,77,99,90]\nfor i in list:\n    if i <= 66:\n        if 'k1' in dic.keys():\n            dic['k1'].append(i)\n        else:\n            dic['k1']=[i]\n    else:\n        if 'k2' in dic.keys():\n            dic['k2'].append(i)\n        else:\n            dic['k2']=[i]\nprint dic\n")])])]),e("h2",{attrs:{id:"编写登录接口"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#编写登录接口"}},[n._v("#")]),n._v(" 编写登录接口")]),n._v(" "),e("p",[n._v("编写登录接口:")]),n._v(" "),e("ul",[e("li",[n._v("输入用户名、密码")]),n._v(" "),e("li",[n._v("认证成功后显示欢迎信息")]),n._v(" "),e("li",[n._v("输错三次后锁定")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("#coding:utf-8\n\nretry_count=0\nretry_limit=3\nretry_dict={}\nwhile True:\n    username=raw_input('pls input your account>>>').strip()\n    if len(username)==0:\n        print 'username should not be empty！'\n        continue\n    password=raw_input('password>>>').strip()\n\n    account_flag = False\n    with open('account_lock','r') as f:\n        for line in  f.readlines():\n            if username == line.strip():\n                print 'Your account has been locked!'\n                account_flag=True\n                break      #此处如果使用exit呢？\n    if account_flag:\n        break\n\n    account={}\n    with open('accounts') as f:\n        for line in  f.readlines():\n            user,passwd=line.strip().split()\n            account[user]=passwd\n    if username in account.keys():\n        if password == account[username]:\n            print 'login success!'\n            print 'Welcome  %s Login To The Computer!'% username\n            break\n    else:\n        retry_dict[username] = retry_count\n        if retry_count < retry_limit and retry_dict[username] < 3 :\n            print 'username or password is wrong!'\n            print \"retry_count=\",retry_count\n            retry_count += 1\n        else:\n            print 'too mach times,quit now!'\n            break\n        if  retry_dict[username] >= 2:\n            with open('account_lock','a') as f:\n                f.write(username)\n                f.write('\\n')          #可以合并为f.write(username+'\\n')\n                print 'Your account has been locked!'\n                break\n    print retry_dict\n")])])])])}),[],!1,null,null,null);e.default=r.exports}}]);