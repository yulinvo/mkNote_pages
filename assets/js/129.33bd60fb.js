(window.webpackJsonp=window.webpackJsonp||[]).push([[129],{396:function(n,t,e){"use strict";e.r(t);var a=e(13),s=Object(a.a)({},(function(){var n=this,t=n._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h2",{attrs:{id:"进程、线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#进程、线程"}},[n._v("#")]),n._v(" "),t("strong",[n._v("进程、线程")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("进程要操作CPU，必须先创建一个线程\n进程是没有执行概念的，不能执行，要通过线程来操作CPU\n\n同一个进程中的线程 是共享同一块内存空间的\n进程之间内存是独立的\n\n子进程克隆进程的一份数据，进程、子进程、不同子进程之间内存空间是独立的；\n\n两个进程之间如果想通信，必须找到一个中间代理\n\n一个线程可以操作同一进程中的其他线程，但进程只能操作子进程\n\n线程之间没有隶属关系\n子线程也可以启动子线程：A启动子线程B，B启动子线程C，C启动子线程D\n\n\n单核CPU只能执行一个任务，之所以能执行多个任务，是因为太快了，不是轮训的，进程之间有不同的优先级\n4核的CPU是真实的同时执行4个任务\npython里的多线程是假的多线程，同一时间只能在一个核上执行，利用python中多线程的上下文的切换，其实就是单线程在执行（不是太明白！！！）\n    折中的方法是：启用多进程，如果有4个核心，就启用4个进程，每个进程中一个线程，就相当于4个线程在同时运行\npython多线程不适合CPU密集操作的任务，适合IO操作密集型的任务，场景：\n    io 操作不占用CPU，如socketserver\n    计算占用CPU（如：1+1）\n\npython的进程调用的也是操作系统的原生进程\n\n\n线程和子线程是独立的，进程和子进程不是（kill进程子进程就也消失了）\n\n问：进程快还是线程快？    答：没有可比性，进程是一堆资源的集合，也需要创建线程才能操作CPU\n问：启动一个线程快还是启动一个进程快            答：启动线程快\n")])])]),t("p",[t("strong",[n._v("线程简单示例：")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("#coding:utf-8\nimport threading,time\n\ndef run(n):\n    print 'task',n\n    time.sleep(2)\nt1 = threading.Thread(target=run,args=('t1',))            #args后面跟的是元组，args就是传递给run的参数，详见生产者、消费者模型\nt2 = threading.Thread(target=run,args=('t2',))\n\n# run('t1')\n# run('t2') #这种是按照顺序执行，执行完第一个才执行第二个\n\nt1.start()\nt2.start()\n\n\n\nfor i in range(50):                #一次启动50个线程\n    t = threading.Thread(target=run,args=('t-%s' %i,))\n    t.start()\n")])])]),t("p",[t("strong",[n._v("使用类的方法示例：")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("#coding:utf-8\nimport threading,time\n\nclass MyThred(threading.Thread):\n    def __init__(self,n):\n        super(MyThred,self).__init__()\n        self.n = n\ndef run(self):                                            #这里函数必须命名为run\n    print 'task',self.n\n    time.sleep(2)\n\nt1 = MyThred('t1')\nt2 = MyThred('t2')\n\n# t1.run()\n# t2.run()                     #执行完一个才执行第二个任务\n\nt1.start()\n# t1.join()    #=wait  等待t1.start()的执行结果，然后才去执行t2.start()，程序就变成串行的了\nt2.start()\n")])])]),t("h2",{attrs:{id:"gil"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gil"}},[n._v("#")]),n._v(" GIL")]),n._v(" "),t("p",[n._v("GIL：全局解释器锁（python的线程调用的操作系统的原生线程），同一时间只有一个核上在执行，为了避免数据出错；java、C++是自己实现的线程，没有这个问题")]),n._v(" "),t("p",[t("strong",[n._v("说白了就是一个核只能在同一时间运行一个线程。")]),n._v(" "),t("strong",[n._v("对于io密集型任务，python的多线程起到作用，但对于cpu密集型任务，python的多线程几乎占不到任何优势，还有可能因为争夺资源而变慢。")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("Python和多线程（multi-threading）。这是个好主意码？列举一些让Python代码以并行方式运行的方法。\n答案:    Python并不支持真正意义上的多线程。Python中提供了多线程包，但是如果你想通过多线程提高代码的速度，使用多线程包并不是个好主意。Python中有一个被称为Global Interpreter Lock（GIL）的东西，它会确保任何时候你的多个线程中，只有一个被执行。线程的执行速度非常之快，会让你误以为线程是并行执行的，但是实际上都是轮流执行。经过GIL这一道关卡处理，会增加执行的开销。这意味着，如果你想提高代码的运行速度，使用threading包并不是一个很好的方法。\n\n不过还是有很多理由促使我们使用threading包的。如果你想同时执行一些任务，而且不考虑效率问题，那么使用这个包是完全没问题的，而且也很方便。但是大部分情况下，并不是这么一回事，你会希望把多线程的部分外包给操作系统完成（通过开启多个进程），或者是某些调用你的Python代码的外部程序（例如Spark或Hadoop），又或者是你的Python代码调用的其他代码（例如，你可以在Python中调用C函数，用于处理开销较大的多线程工作）。\n\n为什么提这个问题\n因为GIL就是个混账东西（A-hole）。很多人花费大量的时间，试图寻找自己多线程代码中的瓶颈，直到他们明白GIL的存在。\n")])])]),t("p",[n._v("pypy：1，去掉了全局解释器锁  2，动态编译（执行前预编译一部分）")]),n._v(" "),t("p",[n._v("python 2.x 代码上   全局解释器锁：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("import threading,time\n\nlock = threading.Lock()\nnum = 0\n\ndef run(n): #不加锁在mac和ubuntu上常出现加1000次，结果为980、990的情况，少了一点\n    lock.acquire() #加锁，加锁之后就变串行了，测试是否是串行，加个time.sleep(1)\n    global num                        #函数能够使用全局的变量\n    num += 1\n    lock.release() #释放\n\nfor i in range(50):\n    t = threading.Thread(target=run,args=('t-%s' %i,))\n    t.start()\n")])])]),t("p",[n._v("递归锁（Rlock）：（防止锁能混了，那第二把的钥匙去开第一把锁），有嵌套调用的lock的时候")]),n._v(" "),t("p",[n._v("互斥锁（Mutex）：A修改的时候B不能修改")]),n._v(" "),t("p",[n._v("semaphore（信号量）：互斥锁同时只允许一个线程修改数据，而semaphore同时允许一定数量的线程修改数据")]),n._v(" "),t("p",[n._v("Events（）：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("event = threading.Event() \n\nevent.wait()                    #等待标志位被设定\n\n\nevent.set()\n标志位被设定，代表绿灯，直接通行\nevent.clear()\n标志位被清空，代表红灯，wait等待变绿灯\nevent.is_set()\n")])])]),t("h2",{attrs:{id:"多进程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多进程"}},[n._v("#")]),n._v(" "),t("strong",[n._v("多进程")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("#coding:utf-8\nimport  multiprocessing,time,threading\ndef thread_run():\n    print threading._get_ident()            # _get_ident()    获取线程号\ndef run(name):\n    time.sleep(2)\n    print 'hello',name\n    t = threading.Thread(target=thread_run,)            # 每个进程中再启用一个线程\n    t.start()\nif __name__ == '__main__':\n    for i in range(10):\n        p = multiprocessing.Process(target=run,args=('tom %s'%i,))\n        p.start()\n        # p.join()\n")])])]),t("p",[t("strong",[n._v("进程间通信：")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("进程Queue，示例此处没有记录\npipes管道通信，示例此处没有记录\n")])])]),t("p",[n._v("manager，可以实现不同类型数据在不同的进程之间的共享（进程之间默认已经加锁）")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code")])]),t("p",[n._v("进程锁：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("进程锁作用是：当屏幕打印数据时，防止一个进程的数据没有完全打印完时，另一个进程的输出开始打印，在win没怎么出现，但在linux上很常见；示例此处没有记录\n")])])]),t("p",[n._v("进程池（这个很重要）：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("子进程克隆进程的一份数据，为了节省空间\n进程池有两个方法：\n    apply                        # 表现为串行\n    apply_async             #表现为并行\n\npool = Pool(5) # 等同于processes=5,允许进程池同时放入5个进程\n")])])]),t("h2",{attrs:{id:"协程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#协程"}},[n._v("#")]),n._v(" 协程")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("又称微线程，在单线程下实现并发的效果，yeild就是，实际上还是串行，协程是跑在线程里的\n协程不需要加锁，因为本来就是单线程\n一个CPU只能上万个协程都没问题，都是在一个线程里，适合高并发场景\n缺点：\n    因为是单线程，无法利用多核的资源；线程需要和多进程配合使用才能使用多核\n\n协程遇到IO操作就切换，time.sleep(5)，最后变成了只有CPU操作，就很快\n\n先pip安装 greenlet（已经封装好了的协程），    pip2.exe install greenlet\ngreenlet是手动切换，gevent是自动切换，gevent封装的greenlet，安装gevent里面包含greenlet\ngevent碰见io就切换，即使是gevent.sleep(0)也会切换\n\n")])])]),t("p",[n._v("IO操作是操作系统完成的，不是python完成的")]),n._v(" "),t("p",[n._v("内存分为：内核空间、用户空间，用户空间无法访问内核空间；")]),n._v(" "),t("p",[n._v("​\t\t用户打开文件、打开音响，都是内核完成的，数据先被拷贝到操作系统的内核缓冲区，内核将数据拷贝给用户")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("同步IO：\n    阻塞IO：linux中，默认情况下所有的socket都是blocking\n    非阻塞IO：linux下，可以通过设置socket使其变为non-blocking\n    IO多路复用：    内核空间拷贝到用户空间，还要read一下，还是会卡\n            常用的如epoll\n信号驱动IO：（这个不常用）\n异步IO：   相比多路IO，异步IO不用read，不会卡\n")])])]),t("p",[n._v("select、poll、epoll属于IO多路复用：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("select：    最早期的，现在基本也不太用\npoll：没有检测数量的限制，是个过渡阶段\nepoll：监控100个socket交给内核处理，（win不支持epoll）\n\n\nselectors默认使用epoll，win上不支持epoll就会使用select\n")])])])])}),[],!1,null,null,null);t.default=s.exports}}]);